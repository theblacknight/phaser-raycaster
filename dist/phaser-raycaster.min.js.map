{"version":3,"file":"phaser-raycaster.min.js","mappings":"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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\n* @copyright    2023 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n/**\n * Point object\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n */\n \n/**\n * @classdesc\n *\n * Raycaster plugin class.\n * \n * @namespace PhaserRaycaster\n * @class PhaserRaycaster\n * @extends Phaser.Plugins.ScenePlugin\n * @constructor\n * @since 0.6.0\n *\n * @param {Phaser.Scene} scene\n * @param {Phaser.Plugins.PluginManager} pluginManager\n */\n\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\n    }\n\n    /**\n    * Create Raycaster object.\n    *\n    * @method PhaserRaycaster#createRaycaster\n    * @memberof PhaserRaycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    createRaycaster(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n}\n\n//Make sure you export the plugin for webpack to expose\nmodule.exports = PhaserRaycaster;","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            //container's child\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            //transformed container's circle children\n            this._circles = [];\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            this._updateChildMap = container._updateChildMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //if object is not supported\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\n        this.notSupported = true;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete this.object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //add tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n        //assign neighbours\n        points[0].neighbours = [points[1]];\n        points[1].neighbours = [points[0]];\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n    \n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        \n        points[i].neighbours = [\n            prevPoint,\n            nextPoint\n        ];\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n* @param {boolean} [isChild] - Flag definig if it is child container.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, isChild = false) {\n    if(!this.active)\n        return [];\n\n    let points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(this.segmentCount == 0 && !isChild) {\n        if(ray) {\n            //create temporary ray\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n    \n            let tempRay = ray._raycaster.createRay({\n                origin: {\n                    x: vector.getPointB().x,\n                    y: vector.getPointB().y\n                }\n            });\n\n            //calculate tangent rays\n            let rayA = new Phaser.Geom.Line();\n            let rayB = new Phaser.Geom.Line();\n            let c;\n\n            for(let circle of this._circles) {\n                circle.points = [];\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\n\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\n\n                //ray angle\n                let angle = Phaser.Geom.Line.Angle(c);\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n                //adding tangent points\n                circle.points.push(rayA.getPointB());\n                circle.points.push(rayB.getPointB());\n                points.push(rayA.getPointB());\n                points.push(rayB.getPointB());\n            }\n        }\n    }\n    \n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n    this._circles = [];\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    if(this.mapChild) {\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\n    }\n    else {\n        //iterate through container's children\n        container.iterate(function(child){\n            this._updateChildMap(child, points, segments, rotation, offset);\n        }.bind(this));\n\n        //get children intersections\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\n            let childA = container.list[i];\n            let mapA = childA.data.get('raycasterMap');\n            \n            if(!mapA)\n                continue;\n\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n                let childB = container.list[j];\n                let mapB = childB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                    continue;\n\n                //find objects intersections\n                for(let segmentA of mapA.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        //calculate positions after container's rotation\n                        if(rotation !== 0) {\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                            points.push(vector.getPointB());\n                        }\n                        //if rotation === 0\n                        else\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                    }\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n\n/**\n* Update container's child map of points and segments.\n*\n* @method Raycaster.Map#container._updateChildMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.10.3\n*\n* @param {object} [child] - Container's child object.\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\n* @param {number} [rotation] - Container's rotation.\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\n*/\nexport function _updateChildMap(child, points, segments, rotation, offset) {\n    if(!child.data)\n        child.setDataEnabled();\n\n    //if object is not supported\n    if(child.data.get('raycasterMapNotSupported'))\n        return;\n\n    //get child map\n    let map = child.data.get('raycasterMap');\n    if(!map) {\n        map = new this.constructor({\n            object: child,\n            segmentCount: this.segmentCount\n        });\n\n        if(map.notSupported) {\n            map.destroy();\n            child.data.set('raycasterMapNotSupported', true);\n            return;\n        }\n\n        child.data.set('raycasterMap', map);\n    }\n    else\n        map.updateMap();\n\n    //add child points\n    let childPoints = [];\n    for(let point of map.getPoints(false, true)) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n        //if rotation === 0\n        else\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n\n        childPoints.push(points[points.length - 1])\n    }\n\n    //add child segments\n    for(let segment of map.getSegments()) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let pointA = segment.getPointA();\n            let pointB = segment.getPointB();\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n        }\n        //if rotation === 0\n        else\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\n    }\n\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\n    if(map.type == 'Arc' && this.segmentCount == 0) {\n        let circleOffset = new Phaser.Geom.Point();\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\n\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            circleOffset = vector.getPointB();\n        }\n\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\n    }\n    else if(map.type === 'Container') {\n        for(let childMapCircle of map._circles) {\n            let circleOffset = new Phaser.Geom.Point();\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\n\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                circleOffset = vector.getPointB();\n            }\n\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\n        }\n    }\n}\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 0.6.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map_dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this._dynamic = false;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    if(!this.notSupported)\n        this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config,\n    destroy: require('./destroy.js').destroy,\n    get dynamic() {\n        return this._dynamic;\n    },\n    set dynamic(dynamic) {\n        if(this._dynamic == dynamic)\n            return this;\n    \n        if(dynamic) {\n            this._dynamic = true;\n            \n            //add object to raycaster's dynamic objects list\n            if(this._raycaster) {\n                this._raycaster.dynamicMappedObjects.push(this.object);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n        else {\n            this._dynamic = false;\n            \n            //remove object from reycasters' dynamic objects list\n            if(this._raycaster) {\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\n                if(index >= 0)\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n    \n        return this;\n     }\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n    //assign neighbours\n    points[0].neighbours = [points[1]];\n    points[1].neighbours = [points[0]];\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        \n        points[i].neighbours = [\n            prevPoint,\n            nextPoint\n        ];\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is not closed\n    if(!this.object.closePath) {\n       segments.pop();\n       points[0].neighbours.shift();\n       points[points.lenght - 1].neighbours.pop();\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        \n        points[i].neighbours = [\n            prevPoint,\n            nextPoint\n        ];\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {number} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {number} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox, boundingBoxIntersections = [], canTestMap = false;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0)\n            continue;\n\n        //check if bounding box is closer than closest intersection\n        for(let boundingBoxIntersection of boundingBoxIntersections) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) < closestDistance) {\n                canTestMap = true;\n                break;\n            }\n        }\n\n        if(!canTestMap)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n\n        //check container map's circles\n        if(map.type == 'Container' && map._circles.length > 0) {\n            for(let circle of map._circles) {\n                //check if target point is a circle tangent point to ray\n                if(options.target) {\n                    let isTangent = false;\n\n                    for(let point of circle.points) {\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\n                            //get closest intersection\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                            if(distance < closestDistance) {\n                                closestDistance = distance;\n                                closestIntersection = point;\n                                closestObject = map.object;\n                                isTangent = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(isTangent)\n                        continue;\n                }\n\n                let circleIntersections = [];\n\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                    for(let intersection of circleIntersections) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = intersection;\n                            closestObject = map.object;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    let target = {\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    };\n                    target.point.intersection = false;\n                    rayTargets.push(target);\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection) {\n            //if intersection hits target point check if ray \"glanced\" mapped object.\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n\n            if(!castSides) {\n                //castSides = false;\n            }\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\n                //castSides = true;\n            }\n            //check if ray and at least one line between target point and it's neighbours are parallel\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\n                //castSides = true;\n            }\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\n            else {\n                let triangleIntersections = [];\n                let triangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\n                Phaser.Geom.Intersects.GetTriangleToLine(triangle, this._ray, triangleIntersections);\n                \n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\n                for(let triangleIntersection of triangleIntersections) {\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\n                        castSides = false;\n                        break;\n                    }\n                }\n            }\n            \n            //if ray \"glanced\" mapped object cast two additional rays\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCone',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection) {\n            //if intersection hits target point check if ray \"glanced\" mapped object.\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            \n            if(!castSides) {\n                //castSides = false;\n            }\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\n                //castSides = true;\n            }\n            //check if ray and at least one line between target point and it's neighbours are parallel\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\n                //castSides = true;\n            }\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\n            else {\n                let triangleIntersections = [];\n                let triangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\n                Phaser.Geom.Intersects.GetTriangleToLine(triangle, this._ray, triangleIntersections);\n                \n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\n                for(let triangleIntersection of triangleIntersections) {\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\n                        castSides = false;\n                        break;\n                    }\n                }\n            }\n            \n            //if ray \"glanced\" mapped object cast two additional rays\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10.0\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    if(this.graphics)\r\n        this.graphics.destroy();\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {number}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {number}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {number}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(boolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug,\n    destroy: require('./destroy.js').destroy,\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n * @param {number} [angle] - Ray's angle in radians.\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.7';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.10.6\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update, this);\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update, this);\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index === -1) {\r\n                continue;\r\n            }\r\n            \r\n            this.mappedObjects.splice(index, 1);\r\n            \r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap.destroy();\r\n            }\r\n            else {\r\n                object.data.get('raycasterMap').destroy();\r\n            }\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n            \r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else if(object.data)\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n        \r\n        if(this.graphics)\r\n            this.graphics.destroy();\r\n        \r\n        if(this.scene) {\r\n            this.scene.events.removeListener('update', null, this);\r\n        }\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(880);\n"],"names":["root","factory","exports","module","define","amd","self","PhaserRaycaster","_Phaser$Plugins$Scene","_inherits","Phaser","Plugins","ScenePlugin","_super","_createSuper","scene","pluginManager","_this","_classCallCheck","call","_Raycaster","require","key","value","options","arguments","length","undefined","this","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","ray","_points","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","c","rayA","Line","rayB","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","neighbours","_segments","scaleY","geom","segments","_step","newPoints","_iterator","_createForOfIteratorHelper","s","n","done","point","err","e","f","_step2","_iterator2","i","prevPoint","slice","nextPoint","isChild","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","_step3","segmentA","_iterator3","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","_step4","childPoints","_iterator4","_step5","_iterator5","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","_step6","_iterator6","childMapCircle","Map","raycaster","_dynamic","prototype","dynamicMappedObjects","_stats","mappedObjects","static","total","index","indexOf","splice","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","_loop","find","_loop2","segmentIndex","findIndex","x1","y1","x2","y2","closingSegment","matter","composite","Rectangle","min","max","closePath","pop","shift","lenght","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","_i","_verticals","column","filter","_step7","_iterator7","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","result","boundingBoxIntersections","canTestMap","_boundingBox","setTo","_boundingBoxIntersect","boundingBoxIntersection","Equals","isTangent","circleIntersections","GetLineToCircle","_step8","_iterator8","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","_rayTargets","castSides","roundedTarget","BetweenPoints","triangleIntersections","triangle","Triangle","GetTriangleToLine","_i2","_triangleIntersection","triangleIntersection","abs","intersectionA","intersectionB","autoSlice","slicedIntersections","castCone","minAngle","maxAngle","cone","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","onCollideActiveCallback","bodyA","bodyB","onCollideWith","id","setOnCollideWith","func","src","hasOwnProperty","overlap","targets","overlapCircle","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","Raycaster","version","mapPoint","mapSegment","mapBoundingBox","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","_typeof","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","enableMaps","disableMaps","mapppedObject","strokeRectShape","removeListener","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","prop","r","Symbol","toStringTag"],"sourceRoot":""}