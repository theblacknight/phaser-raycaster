{"version":3,"file":"phaser-raycaster.js","mappings":"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AAI,CAAC9K,oBAAoB,EAAE8L,YAAY,CAAC,EAChF,OAAO,IAAI;EAEf,OAAO,KAAK;AAChB;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,GAAGA,CAACjY,OAAO,EAAEgJ,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC3C,UAAU,GAAG2C,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC9E,MAAM,GAAG,IAAI9D,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACqK,IAAI,GAAG,IAAIjN,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,KAAK,GAAG,CAAC;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACqN,IAAI,GAAG,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACxE,QAAQ,GAAGlN,MAAM,CAACgE,IAAI,CAAC0H,gBAAgB;EAC5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACD,cAAc,GAAG,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACK,oBAAoB,GAAG,IAAI9L,MAAM,CAAC2C,IAAI,CAAC4F,MAAM,CAAC,CAAC;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC8J,cAAc,GAAGrS,MAAM,CAACgE,IAAI,CAAC0H,gBAAgB;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiE,wBAAwB,GAAG,IAAI;EACpC;AACJ;A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C,CAAC,CAACpL,CAAC,EAAEoL,aAAa,CAACA,aAAa,CAACtO,MAAM,GAAC,CAAC,CAAC,CAAC+C,CAAC,EAAEuL,aAAa,CAACA,aAAa,CAACtO,MAAM,GAAC,CAAC,CAAC,CAACkD,CAAC,CAAC,CAAC;EAEjM,OAAOiV,MAAM;AACjB;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,SAASH,QAAQA,CAAA,EAAG;EACvB,OAAO,IAAI,CAAC9O,MAAM;AACtB;;;;;;;;;;;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASzJ,SAASA,CAACK,OAAO,EAAE;EAC/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACsY,OAAO,GAAG,QAAQ;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAClZ,KAAK;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACyT,QAAQ;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACF,YAAY,GAAG;IAChBC,OAAO,EAAE,KAAK;IACdxC,IAAI,EAAE,IAAI;IACVhC,IAAI,EAAE,IAAI;IACVyE,QAAQ,EAAE;MACNlQ,GAAG,EAAE,QAAQ;MACb0Q,QAAQ,EAAE,QAAQ;MAClBkF,QAAQ,EAAE,QAAQ;MAClBC,UAAU,EAAE,QAAQ;MACpBC,cAAc,EAAE;IACpB;EACJ,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACK,IAAI,CAACrP,MAAM,GAAG;IACXC,aAAa,EAAE;MACXE,KAAK,EAAE,CAAC;MACRD,MAAM,EAAE,CAAC;MACTjH,O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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/before-startup","webpack://PhaserRaycaster/webpack/startup","webpack://PhaserRaycaster/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\n* @copyright    2023 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n/**\n * Point object\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n */\n \n/**\n * @classdesc\n *\n * Raycaster plugin class.\n * \n * @namespace PhaserRaycaster\n * @class PhaserRaycaster\n * @extends Phaser.Plugins.ScenePlugin\n * @constructor\n * @since 0.6.0\n *\n * @param {Phaser.Scene} scene\n * @param {Phaser.Plugins.PluginManager} pluginManager\n */\n\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\n    }\n\n    /**\n    * Create Raycaster object.\n    *\n    * @method PhaserRaycaster#createRaycaster\n    * @memberof PhaserRaycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    createRaycaster(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n}\n\n//Make sure you export the plugin for webpack to expose\nmodule.exports = PhaserRaycaster;","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            //container's child\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            //transformed container's circle children\n            this._circles = [];\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            this._updateChildMap = container._updateChildMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //if object is not supported\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\n        this.notSupported = true;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete this.object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //add tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n        //assign neighbours\n        points[0].neighbours = [points[1]];\n        points[1].neighbours = [points[0]];\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n    \n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        \n        points[i].neighbours = [\n            prevPoint,\n            nextPoint\n        ];\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n* @param {boolean} [isChild] - Flag definig if it is child container.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, isChild = false) {\n    if(!this.active)\n        return [];\n\n    let points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(this.segmentCount == 0 && !isChild) {\n        if(ray) {\n            //create temporary ray\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n    \n            let tempRay = ray._raycaster.createRay({\n                origin: {\n                    x: vector.getPointB().x,\n                    y: vector.getPointB().y\n                }\n            });\n\n            //calculate tangent rays\n            let rayA = new Phaser.Geom.Line();\n            let rayB = new Phaser.Geom.Line();\n            let c;\n\n            for(let circle of this._circles) {\n                circle.points = [];\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\n\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\n\n                //ray angle\n                let angle = Phaser.Geom.Line.Angle(c);\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n                //adding tangent points\n                circle.points.push(rayA.getPointB());\n                circle.points.push(rayB.getPointB());\n                points.push(rayA.getPointB());\n                points.push(rayB.getPointB());\n            }\n        }\n    }\n    \n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n    this._circles = [];\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    if(this.mapChild) {\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\n    }\n    else {\n        //iterate through container's children\n        container.iterate(function(child){\n            this._updateChildMap(child, points, segments, rotation, offset);\n        }.bind(this));\n\n        //get children intersections\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\n            let childA = container.list[i];\n            let mapA = childA.data.get('raycasterMap');\n            \n            if(!mapA)\n                continue;\n\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n                let childB = container.list[j];\n                let mapB = childB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                    continue;\n\n                //find objects intersections\n                for(let segmentA of mapA.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        //calculate positions after container's rotation\n                        if(rotation !== 0) {\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                            points.push(vector.getPointB());\n                        }\n                        //if rotation === 0\n                        else\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                    }\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n\n/**\n* Update container's child map of points and segments.\n*\n* @method Raycaster.Map#container._updateChildMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.10.3\n*\n* @param {object} [child] - Container's child object.\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\n* @param {number} [rotation] - Container's rotation.\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\n*/\nexport function _updateChildMap(child, points, segments, rotation, offset) {\n    if(!child.data)\n        child.setDataEnabled();\n\n    //if object is not supported\n    if(child.data.get('raycasterMapNotSupported'))\n        return;\n\n    //get child map\n    let map = child.data.get('raycasterMap');\n    if(!map) {\n        map = new this.constructor({\n            object: child,\n            segmentCount: this.segmentCount\n        });\n\n        if(map.notSupported) {\n            map.destroy();\n            child.data.set('raycasterMapNotSupported', true);\n            return;\n        }\n\n        child.data.set('raycasterMap', map);\n    }\n    else\n        map.updateMap();\n\n    //add child points\n    let childPoints = [];\n    for(let point of map.getPoints(false, true)) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n        //if rotation === 0\n        else\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n\n        childPoints.push(points[points.length - 1])\n    }\n\n    //add child segments\n    for(let segment of map.getSegments()) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let pointA = segment.getPointA();\n            let pointB = segment.getPointB();\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n        }\n        //if rotation === 0\n        else\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\n    }\n\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\n    if(map.type == 'Arc' && this.segmentCount == 0) {\n        let circleOffset = new Phaser.Geom.Point();\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\n\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            circleOffset = vector.getPointB();\n        }\n\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\n    }\n    else if(map.type === 'Container') {\n        for(let childMapCircle of map._circles) {\n            let circleOffset = new Phaser.Geom.Point();\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\n\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                circleOffset = vector.getPointB();\n            }\n\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\n        }\n    }\n}\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 0.6.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map_dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this._dynamic = false;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    if(!this.notSupported)\n        this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config,\n    destroy: require('./destroy.js').destroy,\n    get dynamic() {\n        return this._dynamic;\n    },\n    set dynamic(dynamic) {\n        if(this._dynamic == dynamic)\n            return this;\n    \n        if(dynamic) {\n            this._dynamic = true;\n            \n            //add object to raycaster's dynamic objects list\n            if(this._raycaster) {\n                this._raycaster.dynamicMappedObjects.push(this.object);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n        else {\n            this._dynamic = false;\n            \n            //remove object from reycasters' dynamic objects list\n            if(this._raycaster) {\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\n                if(index >= 0)\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n    \n        return this;\n     }\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n    //assign neighbours\n    points[0].neighbours = [points[1]];\n    points[1].neighbours = [points[0]];\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        \n        points[i].neighbours = [\n            prevPoint,\n            nextPoint\n        ];\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is not closed\n    if(!this.object.closePath) {\n       segments.pop();\n       points[0].neighbours.shift();\n       points[points.lenght - 1].neighbours.pop();\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1)[0],\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        \n        points[i].neighbours = [\n            prevPoint,\n            nextPoint\n        ];\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [],\n        segments = [],\n        columns = Array(this.object.layer.data[0].length + 1);\n        \n        for(let i = 0, iLength = columns.length; i < iLength; i++) {\n            columns[i] = [];\n        }\n\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point(this.object.x, this.object.y);\n\n    let row = this.object.layer.data[0],\n        tileWidth = this.object.layer.tileWidth * this.object.scaleX,\n        tileHeight = this.object.layer.tileHeight * this.object.scaleY,\n        startPoint,\n        endPoint;\n\n    //set top horizontal lines\n    if(this.collisionTiles.includes(row[0].index)) {\n        startPoint = new Phaser.Geom.Point(offset.x, offset.y);\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, offset.y);\n\n        columns[0].push(startPoint);\n    }\n\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\n        let tile = row[i];\n        \n        if(!this.collisionTiles.includes(tile.index)) {\n            if(startPoint) {\n                startPoint.neighbours = [endPoint];\n                endPoint.neighbours = [startPoint];\n\n                points.push(startPoint, endPoint);\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\n\n                columns[i].push(endPoint);\n\n                startPoint = false;\n                endPoint = false;\n            }\n            continue;\n        }\n\n        let x = i * tileWidth + offset.x,\n            y = offset.y;\n\n        if(!startPoint) {\n            startPoint = new Phaser.Geom.Point(x, y);\n            columns[i].push(startPoint);\n        }\n\n        if(!endPoint) {\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\n        }\n        else {\n            endPoint.x = x + tileWidth;\n        }\n    }\n\n    if(startPoint) {\n        startPoint.neighbours = [endPoint];\n        endPoint.neighbours = [startPoint];\n\n        points.push(startPoint, endPoint);\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\n\n        columns[row.length].push(endPoint);\n    }\n\n    startPoint = false;\n    endPoint = false;\n\n    for(let i = 1, iLength = this.object.layer.data.length - 1; i < iLength; i++) {\n        row = this.object.layer.data[i];\n        let higherRow = this.object.layer.data[i - 1];\n\n        if(this.collisionTiles.includes(row[0].index) != this.collisionTiles.includes(higherRow[0].index)) {\n            startPoint = new Phaser.Geom.Point(offset.x,  i * tileHeight + offset.y);\n            endPoint = new Phaser.Geom.Point(tileWidth + offset.x, i * tileHeight + offset.y);\n\n            columns[0].push(startPoint);\n        }\n\n        for(let j = 1, jLength = row.length; j < jLength; j++) {\n            let tile = row[j],\n                isCollisionTile = this.collisionTiles.includes(tile.index),\n                isCollisionHigherTile = this.collisionTiles.includes(higherRow[j].index);\n            \n            if(isCollisionTile == isCollisionHigherTile) {\n                if(startPoint) {\n                    startPoint.neighbours = [endPoint];\n                    endPoint.neighbours = [startPoint];\n\n                    points.push(startPoint, endPoint);\n                    segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\n\n                    columns[j].push(endPoint);\n\n                    startPoint = false;\n                    endPoint = false;\n                }\n                continue;\n            }\n    \n            let x = j * tileWidth + offset.x,\n                y = i * tileHeight + offset.y;\n    \n            if(!startPoint) {\n                startPoint = new Phaser.Geom.Point(x, y);\n\n                columns[j].push(startPoint);\n            }\n    \n            if(!endPoint) {\n                endPoint = new Phaser.Geom.Point(x + tileWidth, y);\n            }\n            else {\n                endPoint.x = x + tileWidth;\n            }\n        }\n    \n        if(startPoint) {\n            startPoint.neighbours = [endPoint];\n            endPoint.neighbours = [startPoint];\n\n            points.push(startPoint, endPoint);\n            segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\n\n            columns[row.length].push(endPoint);\n        }\n\n        startPoint = false;\n        endPoint = false;\n    }\n\n    //set bottom horizontal lines\n    row = this.object.layer.data.slice(-1)[0];\n    let y = this.object.layer.data.length * tileHeight + offset.y;\n\n    if(this.collisionTiles.includes(row[0].index)) {\n        startPoint = new Phaser.Geom.Point(offset.x, y);\n        endPoint = new Phaser.Geom.Point(tileWidth + offset.x, y);\n\n        columns[0].push(startPoint);\n    }\n\n    for(let i = 1, iLength = row.length; i < iLength; i++) {\n        let tile = row[i];\n        \n        if(!this.collisionTiles.includes(tile.index)) {\n            if(startPoint) {\n                startPoint.neighbours = [endPoint];\n                endPoint.neighbours = [startPoint];\n\n                points.push(startPoint, endPoint);\n                segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\n\n                columns[i].push(endPoint);\n\n                startPoint = false;\n                endPoint = false;\n            }\n            continue;\n        }\n\n        let x = i * tileWidth + offset.x;\n\n        if(!startPoint) {\n            startPoint = new Phaser.Geom.Point(x, y);\n\n            columns[i].push(startPoint);\n        }\n\n        if(!endPoint) {\n            endPoint = new Phaser.Geom.Point(x + tileWidth, y);\n        }\n        else {\n            endPoint.x = x + tileWidth;\n        }\n    }\n\n    if(startPoint) {\n        startPoint.neighbours = [endPoint];\n        endPoint.neighbours = [startPoint];\n\n        points.push(startPoint, endPoint);\n        segments.push(new Phaser.Geom.Line(startPoint.x, startPoint.y, endPoint.x, endPoint.y));\n\n        columns[i].push(endPoint);\n    }\n\n    //set vertical lines\n    for(let i = 0, iLength = columns.length; i < iLength; i++) {\n        const column = columns[i];\n\n        for(let j = 0, jLength = column.length - 1; j < jLength; j++) {\n            segments.push(new Phaser.Geom.Line(column[j].x, column[j].y, column[j+1].x, column[j+1].y));\n            column[j].neighbours.push(column[j+1]);\n            column[j+1].neighbours.push(column[j]);\n            j++;\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {number} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {number} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox, boundingBoxIntersections = [], canTestMap = false;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0)\n            continue;\n\n        //check if bounding box is closer than closest intersection\n        for(let boundingBoxIntersection of boundingBoxIntersections) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) < closestDistance) {\n                canTestMap = true;\n                break;\n            }\n        }\n\n        if(!canTestMap)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n\n        //check container map's circles\n        if(map.type == 'Container' && map._circles.length > 0) {\n            for(let circle of map._circles) {\n                //check if target point is a circle tangent point to ray\n                if(options.target) {\n                    let isTangent = false;\n\n                    for(let point of circle.points) {\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\n                            //get closest intersection\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                            if(distance < closestDistance) {\n                                closestDistance = distance;\n                                closestIntersection = point;\n                                closestObject = map.object;\n                                isTangent = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(isTangent)\n                        continue;\n                }\n\n                let circleIntersections = [];\n\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                    for(let intersection of circleIntersections) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = intersection;\n                            closestObject = map.object;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    let target = {\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    };\n                    target.point.intersection = false;\n                    rayTargets.push(target);\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection) {\n            //if intersection hits target point check if ray \"glanced\" mapped object.\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n\n            if(!castSides) {\n                //castSides = false;\n            }\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\n                //castSides = true;\n            }\n            //check if ray and at least one line between target point and it's neighbours are parallel\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\n                //castSides = true;\n            }\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\n            else {\n                let triangleIntersections = [];\n                let triangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\n                Phaser.Geom.Intersects.GetTriangleToLine(triangle, this._ray, triangleIntersections);\n                \n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\n                for(let triangleIntersection of triangleIntersections) {\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\n                        castSides = false;\n                        break;\n                    }\n                }\n            }\n            \n            //if ray \"glanced\" mapped object cast two additional rays\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCone',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection) {\n            //if intersection hits target point check if ray \"glanced\" mapped object.\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            \n            if(!castSides) {\n                //castSides = false;\n            }\n            else if(!target.point.neighbours || target.point.neighbours.length < 2) {\n                //castSides = true;\n            }\n            //check if ray and at least one line between target point and it's neighbours are parallel\n            else if(Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[0])) < 0.0001\n                || Phaser.Math.Angle.Normalize(this.angle - Phaser.Math.Angle.BetweenPoints(this.origin, target.point.neighbours[1])) < 0.0001) {\n                //castSides = true;\n            }\n            //check if ray crossed more than 1 points of triangle created by tatget point and it's neighbours\n            else {\n                let triangleIntersections = [];\n                let triangle = new Phaser.Geom.Triangle(target.point.x, target.point.y, target.point.neighbours[0].x, target.point.neighbours[0].y, target.point.neighbours[1].x, target.point.neighbours[1].y);\n                Phaser.Geom.Intersects.GetTriangleToLine(triangle, this._ray, triangleIntersections);\n                \n                //if point of intersection of ray and tirangle are close to arget point, assume ray \"glanced\" triangle.\n                for(let triangleIntersection of triangleIntersections) {\n                    if(Math.abs(target.point.x - triangleIntersection.x) > 0.0001 && Math.abs(target.point.y - triangleIntersection.y) > 0.0001) {\n                        castSides = false;\n                        break;\n                    }\n                }\n            }\n            \n            //if ray \"glanced\" mapped object cast two additional rays\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10.0\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    if(this.graphics)\r\n        this.graphics.destroy();\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {number}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {number}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {number}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(boolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug,\n    destroy: require('./destroy.js').destroy,\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n * @param {number} [angle] - Ray's angle in radians.\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.7';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.10.6\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update, this);\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update, this);\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index === -1) {\r\n                continue;\r\n            }\r\n            \r\n            this.mappedObjects.splice(index, 1);\r\n            \r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap.destroy();\r\n            }\r\n            else {\r\n                object.data.get('raycasterMap').destroy();\r\n            }\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n            \r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else if(object.data)\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n        \r\n        if(this.graphics)\r\n            this.graphics.destroy();\r\n        \r\n        if(this.scene) {\r\n            this.scene.events.removeListener('update', null, this);\r\n        }\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.js\");\n",""],"names":["PhaserRaycaster","_Phaser$Plugins$Scene","_inherits","_super","_createSuper","scene","pluginManager","_this","_classCallCheck","call","_Raycaster","require","Raycaster","_createClass","key","value","createRaycaster","options","arguments","length","undefined","Phaser","Plugins","ScenePlugin","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","ray","_points","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","neighbours","_segments","scaleY","geom","segments","newPoints","_iterator","_createForOfIteratorHelper","_step","s","n","done","point","err","e","f","_iterator2","_step2","i","prevPoint","slice","nextPoint","isChild","tempRay","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","_iterator3","_step3","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","childPoints","_iterator4","_step4","_iterator5","_step5","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","_iterator6","_step6","childMapCircle","Map","raycaster","_dynamic","prototype","dynamicMappedObjects","_stats","mappedObjects","static","total","index","indexOf","splice","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","_loop","find","_loop2","segmentIndex","findIndex","x1","y1","x2","y2","_ret","closingSegment","matter","composite","Rectangle","min","max","closePath","pop","shift","lenght","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","columns","Array","layer","row","tileWidth","tileHeight","startPoint","endPoint","includes","tile","higherRow","isCollisionTile","isCollisionHigherTile","column","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","boundingBoxIntersections","canTestMap","_boundingBox","setTo","width","height","_i","_boundingBoxIntersect","boundingBoxIntersection","Equals","isTangent","circleIntersections","GetLineToCircle","_iterator7","_step7","_iterator8","_step8","result","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","_rayTargets","castSides","roundedTarget","BetweenPoints","triangleIntersections","triangle","Triangle","GetTriangleToLine","_i2","_triangleIntersection","triangleIntersection","abs","intersectionA","intersectionB","autoSlice","slicedIntersections","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","version","mapPoint","mapSegment","mapBoundingBox","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","_typeof","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","enableMaps","disableMaps","mapppedObject","strokeRectShape","removeListener"],"sourceRoot":""}