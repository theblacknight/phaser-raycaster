{"version":3,"file":"phaser-raycaster.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA,IAeMA,eAAe,0BAAAC,qBAAA;EAAAC,SAAA,CAAAF,eAAA,EAAAC,qBAAA;EAAA,IAAAE,MAAA,GAAAC,YAAA,CAAAJ,eAAA;EACjB,SAAAA,gBAAYK,KAAK,EAAEC,aAAa,EAAE;IAAA,IAAAC,KAAA;IAAAC,eAAA,OAAAR,eAAA;IAC9BO,KAAA,GAAAJ,MAAA,CAAAM,IAAA,OAAMJ,KAAK,EAAEC,aAAa;IAE1BC,KAAA,CAAKG,UAAU,GAAGC,qFAAwC;IAAC,OAAAJ,KAAA;EAC/D;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAhBIM,YAAA,CAAAb,eAAA;IAAAc,GAAA;IAAAC,KAAA,EAiBA,SAAAC,gBAAA,EAA8B;MAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;MACxBD,OAAO,CAACZ,KAAK,GAAG,IAAI,CAACA,KAAK;MAC1B,OAAO,IAAI,IAAI,CAACK,UAAU,CAACO,OAAO,CAAC;IACvC;EAAC;EAAA,OAAAjB,eAAA;AAAA,EA3ByBqB,MAAM,CAACC,OAAO,CAACC,WAAW,GA8BxD;AACAC,MAAM,CAACC,OAAO,GAAGzB,eAAe;;;;;;;;;;;;;;;AC3DhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS0B,cAAcA,CAAA,EAAG;EAC7B,OAAO,IAAI,CAACC,MAAM,CAACC,SAAS,CAAC,CAAC;AAClC;;;;;;;;;;;;;;;ACbA,IAAIC,SAAS,GAAGlB,mBAAO,CAAC,sEAA4B,CAAC;AACrD,IAAImB,IAAI,GAAGnB,mBAAO,CAAC,4DAAuB,CAAC;AAC3C,IAAIoB,OAAO,GAAGpB,mBAAO,CAAC,kEAA0B,CAAC;AACjD,IAAIqB,GAAG,GAAGrB,mBAAO,CAAC,gEAAyB,CAAC;AAC5C,IAAIsB,SAAS,GAAGtB,mBAAO,CAAC,sEAA4B,CAAC;AACrD,IAAIuB,OAAO,GAAGvB,mBAAO,CAAC,kEAA0B,CAAC;AACjD,IAAIwB,UAAU,GAAGxB,mBAAO,CAAC,wEAA6B,CAAC;AACvD,IAAIyB,YAAY,GAAGzB,mBAAO,CAAC,sDAAoB,CAAC;AAChD,IAAI0B,WAAW,GAAG1B,mBAAO,CAAC,kDAAkB,CAAC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS2B,MAAMA,CAACrB,OAAO,EAAE;EAC5B,IAAI,CAACU,MAAM,GAAGV,OAAO,CAACU,MAAM;EAC5B;EACA,IAAGV,OAAO,CAACsB,IAAI,KAAKnB,SAAS,EACzBH,OAAO,CAACsB,IAAI,GAAGtB,OAAO,CAACU,MAAM,CAACY,IAAI;EACtC,IAAGtB,OAAO,CAACsB,IAAI,KAAK,MAAM,IAAItB,OAAO,CAACsB,IAAI,KAAK,WAAW,EACtDtB,OAAO,CAACsB,IAAI,GAAG,YAAY;EAC/B,IAAI,CAACA,IAAI,GAAGtB,OAAO,CAACsB,IAAI;EAExB,QAAOtB,OAAO,CAACsB,IAAI;IACf,KAAK,SAAS;MACV,IAAI,CAACC,SAAS,GAAGT,OAAO,CAACS,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGV,OAAO,CAACU,WAAW;MACtC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGX,OAAO,CAACW,SAAS;MAClC;IACJ,KAAK,KAAK;MACN;MACA,IAAI,CAACN,YAAY,GAAInB,OAAO,CAACmB,YAAY,GAAInB,OAAO,CAACmB,YAAY,GAAG,CAAC;MACrE,IAAI,CAACO,MAAM,GAAI1B,OAAO,CAACmB,YAAY,GAAI,KAAK,GAAG,IAAI;MACnD,IAAI,CAACI,SAAS,GAAGR,GAAG,CAACQ,SAAS;MAC9B,IAAI,CAACC,WAAW,GAAGT,GAAG,CAACS,WAAW;MAClC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGV,GAAG,CAACU,SAAS;MAC9B,IAAI,CAACE,eAAe,GAAGR,YAAY,CAACQ,eAAe;MACnD;IACJ,KAAK,MAAM;MACP,IAAI,CAACJ,SAAS,GAAGV,IAAI,CAACU,SAAS;MAC/B,IAAI,CAACC,WAAW,GAAGX,IAAI,CAACW,WAAW;MACnC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGZ,IAAI,CAACY,SAAS;MAC/B;IACJ,KAAK,WAAW;MACZ;MACA,IAAI,CAACG,QAAQ,GAAI5B,OAAO,CAAC4B,QAAQ,GAAI5B,OAAO,CAAC4B,QAAQ,GAAG,IAAI;MAC5D;MACA,IAAI,CAACT,YAAY,GAAInB,OAAO,CAACmB,YAAY,GAAInB,OAAO,CAACmB,YAAY,GAAG,CAAC;MACrE;MACA,IAAI,CAACU,QAAQ,GAAG,EAAE;MAClB,IAAI,CAACN,SAAS,GAAGP,SAAS,CAACO,SAAS;MACpC,IAAI,CAACC,WAAW,GAAGR,SAAS,CAACQ,WAAW;MACxC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGT,SAAS,CAACS,SAAS;MACpC,IAAI,CAACK,eAAe,GAAGd,SAAS,CAACc,eAAe;MAChD,IAAI,CAACH,eAAe,GAAGR,YAAY,CAACQ,eAAe;MACnD;IACJ,KAAK,oBAAoB;MACrB;MACA,IAAI,CAACI,cAAc,GAAI/B,OAAO,CAAC+B,cAAc,GAAI/B,OAAO,CAAC+B,cAAc,GAAG,EAAE;MAC5E,IAAI,CAACR,SAAS,GAAGN,OAAO,CAACM,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGP,OAAO,CAACO,WAAW;MACtC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGR,OAAO,CAACQ,SAAS;MAClC,IAAI,CAACO,iBAAiB,GAAGf,OAAO,CAACe,iBAAiB;MAClD;MACA,IAAI,CAACtB,MAAM,CAACuB,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC;MAC1B;IACJ,KAAK,qBAAqB;MACtB;MACA,IAAI,CAACF,cAAc,GAAI/B,OAAO,CAAC+B,cAAc,GAAI/B,OAAO,CAAC+B,cAAc,GAAG,EAAE;MAC5E,IAAI,CAACR,SAAS,GAAGN,OAAO,CAACM,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGP,OAAO,CAACO,WAAW;MACtC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGR,OAAO,CAACQ,SAAS;MAClC,IAAI,CAACO,iBAAiB,GAAGf,OAAO,CAACe,iBAAiB;MAClD;MACA,IAAI,CAACtB,MAAM,CAACuB,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC;MAC1B;IACJ,KAAK,cAAc;MACf;MACA,IAAI,CAACF,cAAc,GAAI/B,OAAO,CAAC+B,cAAc,GAAI/B,OAAO,CAAC+B,cAAc,GAAG,EAAE;MAC5E,IAAI,CAACR,SAAS,GAAGN,OAAO,CAACM,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGP,OAAO,CAACO,WAAW;MACtC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGR,OAAO,CAACQ,SAAS;MAClC,IAAI,CAACO,iBAAiB,GAAGf,OAAO,CAACe,iBAAiB;MAClD;MACA,IAAI,CAACtB,MAAM,CAACuB,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC;MAC1B;IACJ,KAAK,YAAY;MACb;MACA,IAAI,CAACC,WAAW,GAAIlC,OAAO,CAACkC,WAAW,GAAI,IAAI,GAAG,KAAK;MACvD;MACA,IAAI,CAACC,oBAAoB,GAAInC,OAAO,CAACmC,oBAAoB,GAAI,IAAI,GAAG,KAAK;MACzE,IAAI,CAACT,MAAM,GAAG,KAAK;MACnB,IAAI,CAACH,SAAS,GAAGL,UAAU,CAACK,SAAS;MACrC,IAAI,CAACC,WAAW,GAAGN,UAAU,CAACM,WAAW;MACzC,IAAI,CAACf,cAAc,GAAGS,UAAU,CAACT,cAAc;MAC/C,IAAI,CAACgB,SAAS,GAAGP,UAAU,CAACO,SAAS;MACrC;IACJ;MACI,IAAI,CAACF,SAAS,GAAGX,SAAS,CAACW,SAAS;MACpC,IAAI,CAACC,WAAW,GAAGZ,SAAS,CAACY,WAAW;MACxC,IAAI,CAACf,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACgB,SAAS,GAAGb,SAAS,CAACa,SAAS;EAC5C;;EAEA;EACA,IAAG,IAAI,CAACH,IAAI,IAAI,YAAY,IAAI,OAAO,IAAI,CAACZ,MAAM,CAACC,SAAS,KAAK,UAAU,EAAE;IACzE,IAAI,CAACyB,YAAY,GAAG,IAAI;EAC5B;;EAEA;EACA,IAAI,CAACC,OAAO,GAAIrC,OAAO,CAACqC,OAAO,IAAI,IAAI,GAAI,IAAI,GAAG,KAAK;;EAEvD;EACA,IAAI,CAACC,MAAM,GAAItC,OAAO,CAACsC,MAAM,KAAKnC,SAAS,GAAIH,OAAO,CAACsC,MAAM,GAAG,IAAI;EAEpE,OAAO,IAAI;AACf;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,SAASC,OAAOA,CAAA,EAAG;EACvB;EACA,IAAG,IAAI,CAAC7B,MAAM,CAACY,IAAI,KAAK,MAAM,IAAI,IAAI,CAACZ,MAAM,CAACY,IAAI,KAAK,WAAW,EAAE;IAChE,OAAO,IAAI,CAACZ,MAAM,CAAC8B,YAAY;EACnC,CAAC,MACI,IAAG,IAAI,CAAC9B,MAAM,CAAC+B,IAAI,EAAE;IACtB,IAAI,CAAC/B,MAAM,CAAC+B,IAAI,CAACC,MAAM,CAAC,cAAc,CAAC;EAC3C;EAEA,KAAI,IAAI7C,GAAG,IAAI,IAAI,EAAE;IACjB,OAAO,IAAI,CAACA,GAAG,CAAC;EACpB;AACH;;;;;;;;;;;;;;;;;;;;ACpBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS0B,SAASA,CAAA,EAAc;EAAA,IAAboB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EAEb,IAAG,IAAI,CAACM,OAAO,CAAC1C,MAAM,GAAG,CAAC,EACtB,OAAO,IAAI,CAAC0C,OAAO;EAEvB,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACwC,YAAY,IAAI,IAAI,CAACxC,MAAM,CAACyC,OAAO,GAAG,GAAG,CAAC;EACjFL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,aAAa,IAAI,IAAI,CAAC3C,MAAM,CAAC4C,OAAO,GAAG,GAAG,CAAC;;EAElF;EACA,IAAGX,GAAG,EAAE;IACJ,IAAIY,IAAI,GAAG,IAAInD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;IACjC,IAAIC,IAAI,GAAG,IAAIrD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;IACjC,IAAIE,CAAC;IAEL,IAAIC,QAAQ,GAAG,IAAI,CAACjD,MAAM,CAACiD,QAAQ;IAEnC,IAAGA,QAAQ,KAAK,CAAC,EAAE;MACf,IAAIC,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEN,MAAM,CAACG,CAAC,EAAEH,MAAM,CAACM,CAAC,CAAC;MACnFhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;MAC7I,IAAII,EAAE,GAAGJ,MAAM,CAACK,SAAS,CAAC,CAAC;MAC3BP,CAAC,GAAG,IAAItD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACb,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEY,EAAE,CAACf,CAAC,EAAEe,EAAE,CAACZ,CAAC,CAAC;IACpE,CAAC,MACI;MACDM,CAAC,GAAG,IAAItD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACb,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEN,MAAM,CAACG,CAAC,EAAEH,MAAM,CAACM,CAAC,CAAC;IAC5E;IAEA,IAAIe,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAAClE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGU,IAAI,CAACE,GAAG,CAAC,IAAI,CAAC5D,MAAM,CAAC6D,MAAM,GAAG,IAAI,CAAC7D,MAAM,CAAC8D,MAAM,EAAE,CAAC,CAAC,CAAC;;IAEzH;IACA,IAAIC,KAAK,GAAGrE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACJ,CAAC,CAAC;IACrC,IAAIgB,MAAM,GAAGN,IAAI,CAACO,IAAI,CAAE,IAAI,CAACjE,MAAM,CAAC6D,MAAM,GAAG,IAAI,CAAC7D,MAAM,CAAC8D,MAAM,GAAIpE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,CAAC;IAC9FtD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACN,IAAI,EAAEZ,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;IACxF/D,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACJ,IAAI,EAAEd,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;;IAExF;IACAtB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC;IAC7BpB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,CAAC,CAAC,CAAC;EACjC;EAEA,OAAOpB,MAAM;AACjB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASrB,WAAWA,CAAA,EAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACuC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,SAASA,CAAA,EAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAG,CAAC,IAAI,CAACnB,YAAY,EAAE;IACnB,IAAI,CAACyB,OAAO,GAAG,EAAE;IACjB,IAAI,CAACiC,SAAS,GAAG,EAAE;IACnB,OAAO,IAAI;EACf;;EAEA;EACA,IAAI/B,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACwC,YAAY,GAAG,IAAI,CAACxC,MAAM,CAACyC,OAAO,GAAG,IAAI,CAACzC,MAAM,CAAC6D,MAAM,GAAG,IAAI,CAAC7D,MAAM,CAAC8D,MAAM;EACnH1B,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,aAAa,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO,GAAG,IAAI,CAAC5C,MAAM,CAAC6D,MAAM,GAAG,IAAI,CAAC7D,MAAM,CAACoE,MAAM;;EAEpH;EACA,IAAIjC,MAAM,GAAG,IAAI,CAACnC,MAAM,CAACqE,IAAI,CAACxD,SAAS,CAAC,IAAI,CAACJ,YAAY,CAAC;EAC1D,IAAI6D,QAAQ,GAAG,EAAE;;EAEjB;EACA;EACA,IAAIrB,QAAQ,GAAG,IAAI,CAACjD,MAAM,CAACiD,QAAQ;EACnC,IAAGA,QAAQ,KAAK,CAAC,EAAE;IACf,IAAIsB,SAAS,GAAG,EAAE;IAAC,IAAAC,SAAA,GAAAC,0BAAA,CACFtC,MAAM;MAAAuC,KAAA;IAAA;MAAvB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAyB;QAAA,IAAjBC,KAAK,GAAAJ,KAAA,CAAAtF,KAAA;QACT,IAAI8D,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAACuC,CAAC,GAAG,CAACuC,KAAK,CAACvC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC6D,MAAM,IAAI,IAAI,CAAC7D,MAAM,CAAC8D,MAAM,EAAE,IAAI,CAAC9D,MAAM,CAAC0C,CAAC,GAAG,CAACoC,KAAK,CAACpC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC6D,MAAM,IAAI,IAAI,CAAC7D,MAAM,CAACoE,MAAM,CAAC;QACzM1E,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;QAC7IqB,SAAS,CAACL,IAAI,CAAChB,MAAM,CAACK,SAAS,CAAC,CAAC,CAAC;MACtC;IAAC,SAAAwB,GAAA;MAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;IAAA;MAAAP,SAAA,CAAAS,CAAA;IAAA;IACD9C,MAAM,GAAGoC,SAAS;EACtB;EACA;EAAA,KACK;IAAA,IAAAW,UAAA,GAAAT,0BAAA,CACgBtC,MAAM;MAAAgD,MAAA;IAAA;MAAvB,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAAyB;QAAA,IAAjBC,MAAK,GAAAK,MAAA,CAAA/F,KAAA;QACT0F,MAAK,CAACvC,CAAC,GAAGuC,MAAK,CAACvC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;QACjDuC,MAAK,CAACpC,CAAC,GAAGoC,MAAK,CAACpC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;MACrD;IAAC,SAAAqC,GAAA;MAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;IAAA;MAAAG,UAAA,CAAAD,CAAA;IAAA;EACL;;EAEA;EACA,KAAI,IAAIG,CAAC,GAAG,CAAC,EAAE5F,MAAM,GAAG2C,MAAM,CAAC3C,MAAM,EAAE4F,CAAC,GAAG5F,MAAM,EAAE4F,CAAC,EAAE,EAAE;IACpD,IAAGA,CAAC,GAAC,CAAC,GAAG5F,MAAM,EACf8E,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACiD,CAAC,CAAC,CAAC7C,CAAC,EAAEJ,MAAM,CAACiD,CAAC,CAAC,CAAC1C,CAAC,EAAEP,MAAM,CAACiD,CAAC,GAAC,CAAC,CAAC,CAAC7C,CAAC,EAAEJ,MAAM,CAACiD,CAAC,GAAC,CAAC,CAAC,CAAC1C,CAAC,CAAC,CAAC,CAAC,KAE5F4B,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACiD,CAAC,CAAC,CAAC7C,CAAC,EAAEJ,MAAM,CAACiD,CAAC,CAAC,CAAC1C,CAAC,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACI,CAAC,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAACO,CAAC,CAAC,CAAC;EAC3F;EAEA,IAAI,CAACR,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EACzB,OAAO,IAAI;AACf;AAAC;;;;;;;;;;;;;;;;;;;;;AC5ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASzD,SAASA,CAAA,EAA+B;EAAA,IAA9BoB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAAA,IAAE8F,OAAO,GAAA9F,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAClD,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EAEb,IAAIO,MAAM,GAAG,IAAI,CAACD,OAAO;EACzB;EACA,IAAIE,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACwC,YAAY,GAAG,IAAI,CAACxC,MAAM,CAACyC,OAAO;EACzEL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,aAAa,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO;;EAE1E;EACA,IAAG,IAAI,CAACnC,YAAY,IAAI,CAAC,IAAI,CAAC4E,OAAO,EAAE;IACnC,IAAGpD,GAAG,EAAE;MACJ;MACA,IAAIiB,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC,EAAE,CAAC,EAAEb,GAAG,CAACuB,MAAM,CAACjB,CAAC,GAAGH,MAAM,CAACG,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,GAAGN,MAAM,CAACM,CAAC,CAAC;MACzFhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,CAAC,EAAE,CAAC,EAAExD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAG,IAAI,CAAClD,MAAM,CAACiD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;MAEjI,IAAIoC,OAAO,GAAGrD,GAAG,CAACsD,UAAU,CAACC,SAAS,CAAC;QACnChC,MAAM,EAAE;UACJjB,CAAC,EAAEW,MAAM,CAACK,SAAS,CAAC,CAAC,CAAChB,CAAC;UACvBG,CAAC,EAAEQ,MAAM,CAACK,SAAS,CAAC,CAAC,CAACb;QAC1B;MACJ,CAAC,CAAC;;MAEF;MACA,IAAIG,IAAI,GAAG,IAAInD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;MACjC,IAAIC,IAAI,GAAG,IAAIrD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;MACjC,IAAIE,CAAC;MAAC,IAAAwB,SAAA,GAAAC,0BAAA,CAEY,IAAI,CAACtD,QAAQ;QAAAuD,KAAA;MAAA;QAA/B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAiC;UAAA,IAAzB7D,MAAM,GAAA0D,KAAA,CAAAtF,KAAA;UACV4B,MAAM,CAACmB,MAAM,GAAG,EAAE;UAClBa,CAAC,GAAG,IAAItD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACb,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAE1B,MAAM,CAACuB,CAAC,EAAEvB,MAAM,CAAC0B,CAAC,CAAC;UAExE,IAAIe,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAAClE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGU,IAAI,CAACE,GAAG,CAAC5C,MAAM,CAAC6C,MAAM,EAAE,CAAC,CAAC,CAAC;;UAE/F;UACA,IAAIE,KAAK,GAAGrE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACJ,CAAC,CAAC;UACrC,IAAIgB,MAAM,GAAGN,IAAI,CAACO,IAAI,CAAEjD,MAAM,CAAC6C,MAAM,GAAInE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,CAAC;UACpEtD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACN,IAAI,EAAEZ,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;UACxF/D,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACJ,IAAI,EAAEd,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;;UAExF;UACAzC,MAAM,CAACmB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC;UACpCvC,MAAM,CAACmB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,CAAC,CAAC,CAAC;UACpCpB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC;UAC7BpB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,CAAC,CAAC,CAAC;QACjC;MAAC,SAAAwB,GAAA;QAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;MAAA;QAAAP,SAAA,CAAAS,CAAA;MAAA;IACL;EACJ;EAEA,OAAO9C,MAAM;AACjB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASrB,WAAWA,CAAA,EAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EAEb,OAAO,IAAI,CAACuC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,SAASA,CAAA,EAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAIO,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;EACjB,IAAIhE,SAAS,GAAG,IAAI,CAACN,MAAM;EAC3B,IAAI,CAACmB,QAAQ,GAAG,EAAE;;EAElB;EACA,IAAIiB,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACwC,YAAY,GAAG,IAAI,CAACxC,MAAM,CAACyC,OAAO;EACzEL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,aAAa,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO;EAE1E,IAAIK,QAAQ,GAAG3C,SAAS,CAAC2C,QAAQ;EAEjC,IAAG,IAAI,CAAC/B,QAAQ,EAAE;IACd,IAAI,CAACE,eAAe,CAAC,IAAI,CAACF,QAAQ,EAAEiB,MAAM,EAAEmC,QAAQ,EAAErB,QAAQ,EAAEb,MAAM,CAAC;EAC3E,CAAC,MACI;IACD;IACA9B,SAAS,CAACmF,OAAO,CAAC,UAASC,KAAK,EAAC;MAC7B,IAAI,CAACtE,eAAe,CAACsE,KAAK,EAAEvD,MAAM,EAAEmC,QAAQ,EAAErB,QAAQ,EAAEb,MAAM,CAAC;IACnE,CAAC,CAACuD,IAAI,CAAC,IAAI,CAAC,CAAC;;IAEb;IACA,KAAI,IAAIP,CAAC,GAAG,CAAC,EAAEQ,OAAO,GAAGtF,SAAS,CAACuF,IAAI,CAACrG,MAAM,EAAE4F,CAAC,GAAGQ,OAAO,EAAER,CAAC,EAAE,EAAC;MAC7D,IAAIU,MAAM,GAAGxF,SAAS,CAACuF,IAAI,CAACT,CAAC,CAAC;MAC9B,IAAIW,IAAI,GAAGD,MAAM,CAAC/D,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;MAE1C,IAAG,CAACD,IAAI,EACJ;MAEJ,KAAI,IAAIE,CAAC,GAAGb,CAAC,GAAC,CAAC,EAAEc,OAAO,GAAG5F,SAAS,CAACuF,IAAI,CAACrG,MAAM,EAAEyG,CAAC,GAAGC,OAAO,EAAED,CAAC,EAAE,EAAC;QAC/D,IAAIE,MAAM,GAAG7F,SAAS,CAACuF,IAAI,CAACI,CAAC,CAAC;QAC9B,IAAIG,IAAI,GAAGD,MAAM,CAACpE,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;QAC1C;QACA,IAAG,CAACI,IAAI,IAAI,CAAC1G,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACC,oBAAoB,CAACR,MAAM,CAAC7F,SAAS,CAAC,CAAC,EAAEkG,MAAM,CAAClG,SAAS,CAAC,CAAC,CAAC,EAC5F;;QAEJ;QAAA,IAAAiF,UAAA,GAAAT,0BAAA,CACoBsB,IAAI,CAACjF,WAAW,CAAC,CAAC;UAAAqE,MAAA;QAAA;UAAtC,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAAwC;YAAA,IAAhC0B,QAAQ,GAAApB,MAAA,CAAA/F,KAAA;YAAA,IAAAoH,UAAA,GAAA/B,0BAAA,CACQ2B,IAAI,CAACtF,WAAW,CAAC,CAAC;cAAA2F,MAAA;YAAA;cAAtC,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAAwC;gBAAA,IAAhC6B,QAAQ,GAAAD,MAAA,CAAArH,KAAA;gBACZ,IAAIuH,YAAY,GAAG,EAAE;gBACrB,IAAG,CAACjH,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAACL,QAAQ,EAAEG,QAAQ,EAAEC,YAAY,CAAC,EACnE;;gBAEJ;gBACA,IAAG1D,QAAQ,KAAK,CAAC,EAAE;kBACf,IAAIC,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACxC,SAAS,CAACiC,CAAC,EAAEjC,SAAS,CAACoC,CAAC,EAAEiE,YAAY,CAACpE,CAAC,GAAGjC,SAAS,CAACwD,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEoE,YAAY,CAACjE,CAAC,GAAGpC,SAAS,CAAC8D,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;kBACvJhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;kBAC7If,MAAM,CAAC+B,IAAI,CAAChB,MAAM,CAACK,SAAS,CAAC,CAAC,CAAC;gBACnC;gBACA;gBAAA,KAEIpB,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACqE,YAAY,CAACpE,CAAC,GAAGjC,SAAS,CAACwD,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEoE,YAAY,CAACjE,CAAC,GAAGpC,SAAS,CAACwD,MAAM,GAAG1B,MAAM,CAACM,CAAC,CAAC,CAAC;cACtI;YAAC,SAAAqC,GAAA;cAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;YAAA;cAAAyB,UAAA,CAAAvB,CAAA;YAAA;UACL;QAAC,SAAAF,GAAA;UAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;QAAA;UAAAG,UAAA,CAAAD,CAAA;QAAA;MACL;IACJ;EACJ;EAEA,IAAI,CAAC/C,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EAEzB,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASlD,eAAeA,CAACsE,KAAK,EAAEvD,MAAM,EAAEmC,QAAQ,EAAErB,QAAQ,EAAEb,MAAM,EAAE;EACvE,IAAG,CAACsD,KAAK,CAAC3D,IAAI,EACV2D,KAAK,CAACmB,cAAc,CAAC,CAAC;;EAE1B;EACA,IAAGnB,KAAK,CAAC3D,IAAI,CAACiE,GAAG,CAAC,0BAA0B,CAAC,EACzC;;EAEJ;EACA,IAAIc,GAAG,GAAGpB,KAAK,CAAC3D,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;EACxC,IAAG,CAACc,GAAG,EAAE;IACLA,GAAG,GAAG,IAAI,IAAI,CAACC,WAAW,CAAC;MACvB/G,MAAM,EAAE0F,KAAK;MACbjF,YAAY,EAAE,IAAI,CAACA;IACvB,CAAC,CAAC;IAEF,IAAGqG,GAAG,CAACpF,YAAY,EAAE;MACjBoF,GAAG,CAACjF,OAAO,CAAC,CAAC;MACb6D,KAAK,CAAC3D,IAAI,CAACiF,GAAG,CAAC,0BAA0B,EAAE,IAAI,CAAC;MAChD;IACJ;IAEAtB,KAAK,CAAC3D,IAAI,CAACiF,GAAG,CAAC,cAAc,EAAEF,GAAG,CAAC;EACvC,CAAC,MAEGA,GAAG,CAAC/F,SAAS,CAAC,CAAC;;EAEnB;EACA,IAAIkG,WAAW,GAAG,EAAE;EAAC,IAAAC,UAAA,GAAAzC,0BAAA,CACJqC,GAAG,CAACjG,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC;IAAAsG,MAAA;EAAA;IAA3C,KAAAD,UAAA,CAAAvC,CAAA,MAAAwC,MAAA,GAAAD,UAAA,CAAAtC,CAAA,IAAAC,IAAA,GAA6C;MAAA,IAArCC,KAAK,GAAAqC,MAAA,CAAA/H,KAAA;MACT;MACA,IAAG6D,QAAQ,KAAK,CAAC,EAAE;QACf,IAAIC,QAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEoC,KAAK,CAACvC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEuC,KAAK,CAACpC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACjJhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,QAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,QAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,QAAM,CAAC,CAAC;QAC7If,MAAM,CAAC+B,IAAI,CAAChB,QAAM,CAACK,SAAS,CAAC,CAAC,CAAC;MACnC;MACA;MAAA,KAEIpB,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwC,KAAK,CAACvC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEuC,KAAK,CAACpC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACM,CAAC,CAAC,CAAC;MAExHuE,WAAW,CAAC/C,IAAI,CAAC/B,MAAM,CAACA,MAAM,CAAC3C,MAAM,GAAG,CAAC,CAAC,CAAC;IAC/C;;IAEA;EAAA,SAAAuF,GAAA;IAAAmC,UAAA,CAAAlC,CAAA,CAAAD,GAAA;EAAA;IAAAmC,UAAA,CAAAjC,CAAA;EAAA;EAAA,IAAAmC,UAAA,GAAA3C,0BAAA,CACmBqC,GAAG,CAAChG,WAAW,CAAC,CAAC;IAAAuG,MAAA;EAAA;IAApC,KAAAD,UAAA,CAAAzC,CAAA,MAAA0C,MAAA,GAAAD,UAAA,CAAAxC,CAAA,IAAAC,IAAA,GAAsC;MAAA,IAA9ByC,OAAO,GAAAD,MAAA,CAAAjI,KAAA;MACX;MACA,IAAG6D,QAAQ,KAAK,CAAC,EAAE;QACf,IAAIsE,MAAM,GAAGD,OAAO,CAACE,SAAS,CAAC,CAAC;QAChC,IAAIC,MAAM,GAAGH,OAAO,CAAC/D,SAAS,CAAC,CAAC;QAChC,IAAImE,OAAO,GAAG,IAAIhI,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAE6E,MAAM,CAAChF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACpJ,IAAIiF,OAAO,GAAG,IAAIjI,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAE+E,MAAM,CAAClF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACpJhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACuE,OAAO,EAAE,IAAI,CAAC1H,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACsE,OAAO,CAAC,GAAGzE,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACqE,OAAO,CAAC,CAAC;QAChJhI,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACwE,OAAO,EAAE,IAAI,CAAC3H,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACuE,OAAO,CAAC,GAAG1E,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACsE,OAAO,CAAC,CAAC;QAEhJrD,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC4E,OAAO,CAACnE,SAAS,CAAC,CAAC,CAAChB,CAAC,EAAEmF,OAAO,CAACnE,SAAS,CAAC,CAAC,CAACb,CAAC,EAAEiF,OAAO,CAACpE,SAAS,CAAC,CAAC,CAAChB,CAAC,EAAEoF,OAAO,CAACpE,SAAS,CAAC,CAAC,CAACb,CAAC,CAAC,CAAC;MACnI;MACA;MAAA,KAEI4B,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACwE,OAAO,CAACE,SAAS,CAAC,CAAC,CAACjF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAE+E,OAAO,CAACE,SAAS,CAAC,CAAC,CAAC9E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,EAAE4E,OAAO,CAAC/D,SAAS,CAAC,CAAC,CAAChB,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAE+E,OAAO,CAAC/D,SAAS,CAAC,CAAC,CAACb,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC,CAAC;IACvQ;;IAEA;EAAA,SAAAqC,GAAA;IAAAqC,UAAA,CAAApC,CAAA,CAAAD,GAAA;EAAA;IAAAqC,UAAA,CAAAnC,CAAA;EAAA;EACA,IAAG6B,GAAG,CAAClG,IAAI,IAAI,KAAK,IAAI,IAAI,CAACH,YAAY,IAAI,CAAC,EAAE;IAC5C,IAAImH,YAAY,GAAG,IAAIlI,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;IAC1CsF,YAAY,CAACrF,CAAC,GAAG,CAACuE,GAAG,CAAC9G,MAAM,CAACuC,CAAC,GAAGuE,GAAG,CAAC9G,MAAM,CAACwC,YAAY,IAAIsE,GAAG,CAAC9G,MAAM,CAACyC,OAAO,GAAG,GAAG,CAAC,IAAI,IAAI,CAACzC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;IACtHqF,YAAY,CAAClF,CAAC,GAAG,CAACoE,GAAG,CAAC9G,MAAM,CAAC0C,CAAC,GAAGoE,GAAG,CAAC9G,MAAM,CAAC2C,aAAa,IAAImE,GAAG,CAAC9G,MAAM,CAAC4C,OAAO,GAAG,GAAG,CAAC,IAAK,IAAI,CAAC5C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;IAExH,IAAGO,QAAQ,KAAK,CAAC,EAAE;MACf,IAAIC,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEkF,YAAY,CAACrF,CAAC,EAAEqF,YAAY,CAAClF,CAAC,CAAC;MAC/FhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;MAC7I0E,YAAY,GAAG1E,MAAM,CAACK,SAAS,CAAC,CAAC;IACrC;IAEA,IAAI,CAACpC,QAAQ,CAAC+C,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAACD,YAAY,CAACrF,CAAC,EAAEqF,YAAY,CAAClF,CAAC,EAAEoE,GAAG,CAAC9G,MAAM,CAAC6D,MAAM,GAAGiD,GAAG,CAAC9G,MAAM,CAAC8D,MAAM,GAAG,IAAI,CAAC9D,MAAM,CAAC8D,MAAM,CAAC,CAAC;EAC1I,CAAC,MACI,IAAGgD,GAAG,CAAClG,IAAI,KAAK,WAAW,EAAE;IAAA,IAAAkH,UAAA,GAAArD,0BAAA,CACJqC,GAAG,CAAC3F,QAAQ;MAAA4G,MAAA;IAAA;MAAtC,KAAAD,UAAA,CAAAnD,CAAA,MAAAoD,MAAA,GAAAD,UAAA,CAAAlD,CAAA,IAAAC,IAAA,GAAwC;QAAA,IAAhCmD,cAAc,GAAAD,MAAA,CAAA3I,KAAA;QAClB,IAAIwI,aAAY,GAAG,IAAIlI,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;QACtCsF,aAAY,CAACrF,CAAC,GAAGyF,cAAc,CAACzF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;QACjEqF,aAAY,CAAClF,CAAC,GAAGsF,cAAc,CAACtF,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;QAErE,IAAGO,QAAQ,KAAK,CAAC,EAAE;UACf,IAAIC,OAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEkF,aAAY,CAACrF,CAAC,EAAEqF,aAAY,CAAClF,CAAC,CAAC;UAC/FhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,OAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,OAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,OAAM,CAAC,CAAC;UAC7I0E,aAAY,GAAG1E,OAAM,CAACK,SAAS,CAAC,CAAC;QACrC;QAEA,IAAI,CAACpC,QAAQ,CAAC+C,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAACD,aAAY,CAACrF,CAAC,EAAEqF,aAAY,CAAClF,CAAC,EAAEsF,cAAc,CAACnE,MAAM,GAAG,IAAI,CAAC7D,MAAM,CAAC8D,MAAM,CAAC,CAAC;MAC1H;IAAC,SAAAiB,GAAA;MAAA+C,UAAA,CAAA9C,CAAA,CAAAD,GAAA;IAAA;MAAA+C,UAAA,CAAA7C,CAAA;IAAA;EACL;AACJ;;;;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASgD,GAAGA,CAAC3I,OAAO,EAAE4I,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC3C,UAAU,GAAG2C,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACtH,IAAI;EACT;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACgB,MAAM;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACuG,QAAQ,GAAG,KAAK;EACrB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACnH,MAAM,GAAG,KAAK;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAChB,MAAM;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkC,OAAO,GAAG,EAAE;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiC,SAAS,GAAG,EAAE;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACtD,SAAS;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,WAAW;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACf,cAAc;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACgB,SAAS;EAEd,IAAI,CAACJ,MAAM,CAACrB,OAAO,CAAC;EACpB,IAAG,CAAC,IAAI,CAACoC,YAAY,EACjB,IAAI,CAACX,SAAS,CAAC,CAAC;EAEpB,OAAO,IAAI;AACf;AAAC;AAEDkH,GAAG,CAACG,SAAS,GAAG;EACZzH,MAAM,EAAE3B,sEAA6B;EACrC6C,OAAO,EAAE7C,yEAA+B;EACxC,IAAI2C,OAAOA,CAAA,EAAG;IACV,OAAO,IAAI,CAACwG,QAAQ;EACxB,CAAC;EACD,IAAIxG,OAAOA,CAACA,OAAO,EAAE;IACjB,IAAG,IAAI,CAACwG,QAAQ,IAAIxG,OAAO,EACvB,OAAO,IAAI;IAEf,IAAGA,OAAO,EAAE;MACR,IAAI,CAACwG,QAAQ,GAAG,IAAI;;MAEpB;MACA,IAAG,IAAI,CAAC5C,UAAU,EAAE;QAChB,IAAI,CAACA,UAAU,CAAC8C,oBAAoB,CAACnE,IAAI,CAAC,IAAI,CAAClE,MAAM,CAAC;QAEtD,IAAI,CAACuF,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAAC5G,OAAO,GAAG,IAAI,CAAC4D,UAAU,CAAC8C,oBAAoB,CAAC7I,MAAM;QAC1F,IAAI,CAAC+F,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAACC,MAAM,GAAG,IAAI,CAACjD,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAACE,KAAK,GAAG,IAAI,CAAClD,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAAC5G,OAAO;MAC3I;IACJ,CAAC,MACI;MACD,IAAI,CAACwG,QAAQ,GAAG,KAAK;;MAErB;MACA,IAAG,IAAI,CAAC5C,UAAU,EAAE;QAChB,IAAImD,KAAK,GAAG,IAAI,CAACnD,UAAU,CAAC8C,oBAAoB,CAACM,OAAO,CAAC,IAAI,CAAC3I,MAAM,CAAC;QACrE,IAAG0I,KAAK,IAAI,CAAC,EACT,IAAI,CAACnD,UAAU,CAAC8C,oBAAoB,CAACO,MAAM,CAACF,KAAK,EAAE,CAAC,CAAC;QAEzD,IAAI,CAACnD,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAAC5G,OAAO,GAAG,IAAI,CAAC4D,UAAU,CAAC8C,oBAAoB,CAAC7I,MAAM;QAC1F,IAAI,CAAC+F,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAACC,MAAM,GAAG,IAAI,CAACjD,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAACE,KAAK,GAAG,IAAI,CAAClD,UAAU,CAAC+C,MAAM,CAACC,aAAa,CAAC5G,OAAO;MAC3I;IACJ;IAEA,OAAO,IAAI;EACd;AACL,CAAC;AAEDsG,GAAG,CAACG,SAAS,CAACrB,WAAW,GAAGkB,GAAG;;;;;;;;;;;;;;;;;ACrL/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpH,SAASA,CAAA,EAAc;EAAA,IAAboB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACM,OAAO;AACvB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpB,WAAWA,CAAA,EAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACuC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,SAASA,CAAA,EAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAIO,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;;EAEjB;EACA,IAAIlC,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACwC,YAAY,GAAG,IAAI,CAACxC,MAAM,CAACyC,OAAO;EACzEL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,aAAa,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO;EAC1E,IAAI2E,MAAM,GAAG,IAAI,CAACvH,MAAM,CAACqE,IAAI,CAACmD,SAAS,CAAC,CAAC;EACzC,IAAIC,MAAM,GAAG,IAAI,CAACzH,MAAM,CAACqE,IAAI,CAACd,SAAS,CAAC,CAAC;;EAEzC;EACA,IAAIN,QAAQ,GAAG,IAAI,CAACjD,MAAM,CAACiD,QAAQ;EACnC,IAAGA,QAAQ,KAAK,CAAC,EAAE;IACf,IAAIyE,OAAO,GAAG,IAAIhI,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAE6E,MAAM,CAAChF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;IACpJhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACuE,OAAO,EAAE,IAAI,CAAC1H,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACsE,OAAO,CAAC,GAAGzE,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACqE,OAAO,CAAC,CAAC;IAChJH,MAAM,GAAGG,OAAO,CAACnE,SAAS,CAAC,CAAC;IAE5B,IAAIoE,OAAO,GAAG,IAAIjI,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAE+E,MAAM,CAAClF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;IACpJhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACwE,OAAO,EAAE,IAAI,CAAC3H,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACuE,OAAO,CAAC,GAAG1E,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACsE,OAAO,CAAC,CAAC;IAChJF,MAAM,GAAGE,OAAO,CAACpE,SAAS,CAAC,CAAC;;IAE5B;IACApB,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACiF,MAAM,CAAChF,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,CAAC,CAAC;IACtDP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACmF,MAAM,CAAClF,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,CAAC,CAAC;IACtD;IACA4B,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACyE,MAAM,CAAChF,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,EAAE+E,MAAM,CAAClF,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,CAAC,CAAC;EAC/E;EACA;EAAA,KACK;IACD;IACAP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACiF,MAAM,CAAChF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC,CAAC;IACtHP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACmF,MAAM,CAAClF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC,CAAC;IACtH;IACA4B,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACyE,MAAM,CAAChF,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,EAAE+E,MAAM,CAAClF,CAAC,GAAGH,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,EAAE2D,MAAM,CAAC/E,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC,CAAC;EAC/M;EAGA,IAAI,CAACR,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EACzB,OAAO,IAAI;AACf;AAAC;;;;;;;;;;;;;;;;;;;;;AC5FD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASzD,SAASA,CAAA,EAAc;EAAA,IAAboB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EAEb,IAAIiH,IAAI,GAAG,IAAI,CAAC7I,MAAM,CAACY,IAAI,KAAK,MAAM,IAAI,IAAI,CAACZ,MAAM,CAACY,IAAI,KAAK,WAAW,GAAG,IAAI,CAACZ,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC6I,IAAI;;EAE3G;EACA,IAAG5G,GAAG,IAAI,CAAC,IAAI,CAACR,oBAAoB,IAAIoH,IAAI,CAACC,YAAY,GAAG,CAAC,EAAE;IAC3D,IAAI3G,MAAM,GAAG,EAAE;IACf,IAAIU,IAAI,GAAG,IAAInD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;IACjC,IAAIC,IAAI,GAAG,IAAIrD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;IACjC,IAAIE,CAAC,GAAG,IAAItD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACb,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEmG,IAAI,CAACE,QAAQ,CAACxG,CAAC,EAAEsG,IAAI,CAACE,QAAQ,CAACrG,CAAC,CAAC;IAE1F,IAAIe,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAAClE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGU,IAAI,CAACE,GAAG,CAACiF,IAAI,CAACC,YAAY,GAAGD,IAAI,CAACG,KAAK,CAACzG,CAAC,EAAE,CAAC,CAAC,CAAC;;IAElH;IACA,IAAIwB,KAAK,GAAGrE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACJ,CAAC,CAAC;IACrC,IAAIgB,MAAM,GAAGN,IAAI,CAACO,IAAI,CAAE4E,IAAI,CAACC,YAAY,GAAGD,IAAI,CAACG,KAAK,CAACzG,CAAC,GAAI7C,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,CAAC;IACvFtD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACN,IAAI,EAAEZ,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;IACxF/D,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACJ,IAAI,EAAEd,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;;IAExF;IACAtB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,CAAC,CAAC,CAAC;IAC7BpB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,CAAC,CAAC,CAAC;IAE7B,OAAOpB,MAAM;EACjB;EAEA,OAAO,IAAI,CAACD,OAAO;AACvB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpB,WAAWA,CAAA,EAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACuC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,SAASA,CAAA,EAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAIO,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;EACjB,IAAIuE,IAAI,GAAG,IAAI,CAAC7I,MAAM,CAACY,IAAI,KAAK,MAAM,IAAI,IAAI,CAACZ,MAAM,CAACY,IAAI,KAAK,WAAW,GAAG,IAAI,CAACZ,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC6I,IAAI;EAC3G,IAAII,MAAM,GAAG,CAACJ,IAAI,CAAC;EACnB,IAAIK,cAAc,GAAG,KAAK;EAE1B,IAAGL,IAAI,CAACC,YAAY,GAAG,CAAC,IAAI,CAAC,IAAI,CAACrH,oBAAoB,EAAE;IACpD,IAAI,CAACT,MAAM,GAAG,IAAI;IAClB,IAAI,CAACkB,OAAO,GAAGC,MAAM;IACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;IAEzB,OAAO,IAAI;EACf;EAEA,IAAI,CAACtD,MAAM,GAAG,KAAK;EAEnB,IAAG6H,IAAI,CAACjI,IAAI,IAAI,WAAW,EACvBqI,MAAM,GAAGJ,IAAI,CAACI,MAAM;EAExB,IAAMJ,IAAI,CAACM,MAAM,KAAK1J,SAAS,IAAIoJ,IAAI,CAACjI,IAAI,IAAI,WAAW,IAAQiI,IAAI,CAACjI,IAAI,IAAI,WAAW,IAAI,IAAI,CAACe,OAAS,EAAG;IAC5GuH,cAAc,GAAG,IAAI;EACzB;EAAC,IAAA1E,SAAA,GAAAC,0BAAA,CAEmBwE,MAAM;IAAAvE,KAAA;EAAA;IAA1B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA4B;MAAA,IAApBuE,QAAQ,GAAA1E,KAAA,CAAAtF,KAAA;MACZ;MACA,IAAGgK,QAAQ,CAACC,KAAK,CAAC7J,MAAM,KAAK,CAAC,IAAI,IAAI,CAACgC,WAAW,EAAE;QAChD,IAAI8H,QAAQ,GAAGF,QAAQ,CAACC,KAAK,CAAC,CAAC,CAAC,CAACC,QAAQ;QAEzCnH,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgH,QAAQ,CAAC,CAAC,CAAC,CAAC/G,CAAC,EAAE+G,QAAQ,CAAC,CAAC,CAAC,CAAC5G,CAAC,CAAC,CAAC;QAEhE,KAAI,IAAI0C,CAAC,GAAG,CAAC,EAAE5F,MAAM,GAAG8J,QAAQ,CAAC9J,MAAM,EAAE4F,CAAC,GAAG5F,MAAM,EAAE4F,CAAC,EAAE,EAAE;UACtD,IAAImC,MAAM,GAAG,IAAI7H,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgH,QAAQ,CAAClE,CAAC,GAAG,CAAC,CAAC,CAAC7C,CAAC,EAAE+G,QAAQ,CAAClE,CAAC,GAAG,CAAC,CAAC,CAAC1C,CAAC,CAAC;UACxE,IAAI+E,MAAM,GAAG,IAAI/H,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgH,QAAQ,CAAClE,CAAC,CAAC,CAAC7C,CAAC,EAAE+G,QAAQ,CAAClE,CAAC,CAAC,CAAC1C,CAAC,CAAC;UAEhEP,MAAM,CAAC+B,IAAI,CAACuD,MAAM,CAAC;;UAEnB;UACA,IAAIH,QAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACyE,MAAM,CAAChF,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,EAAE+E,MAAM,CAAClF,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,CAAC;UAC1E4B,QAAQ,CAACJ,IAAI,CAACoD,QAAO,CAAC;QAC1B;;QAEA;QACA,IAAIA,OAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACwG,QAAQ,CAACA,QAAQ,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAAC+C,CAAC,EAAE+G,QAAQ,CAACA,QAAQ,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAACkD,CAAC,EAAE4G,QAAQ,CAAC,CAAC,CAAC,CAAC/G,CAAC,EAAE+G,QAAQ,CAAC,CAAC,CAAC,CAAC5G,CAAC,CAAC;QAClI4B,QAAQ,CAACJ,IAAI,CAACoD,OAAO,CAAC;MAC1B;;MAEA;MAAA,KACK,IAAG8B,QAAQ,CAACC,KAAK,CAAC7J,MAAM,GAAG,CAAC,EAAE;QAAA,IAAA+J,KAAA,YAAAA,MAAA,EACiC;UAC5D,IAAID,QAAQ,GAAGF,QAAQ,CAACC,KAAK,CAACjE,EAAC,CAAC,CAACkE,QAAQ;UACzC,IAAI/B,MAAM,GAAG,IAAI7H,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgH,QAAQ,CAAC,CAAC,CAAC,CAAC/G,CAAC,EAAE+G,QAAQ,CAAC,CAAC,CAAC,CAAC5G,CAAC,CAAC;UAEhE,IAAGP,MAAM,CAACqH,IAAI,CAAC,UAAA1E,KAAK;YAAA,OAAIA,KAAK,CAACvC,CAAC,IAAIgF,MAAM,CAAChF,CAAC,IAAIuC,KAAK,CAACpC,CAAC,IAAI6E,MAAM,CAAC7E,CAAC;UAAA,EAAC,KAAKjD,SAAS,EAC7E0C,MAAM,CAAC+B,IAAI,CAACqD,MAAM,CAAC;UAAC,IAAAkC,MAAA,YAAAA,OAAA,EAEkC;YACtD,IAAIhC,MAAM,GAAG,IAAI/H,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgH,QAAQ,CAACrD,CAAC,CAAC,CAAC1D,CAAC,EAAE+G,QAAQ,CAACrD,CAAC,CAAC,CAACvD,CAAC,CAAC;YAChE;YACA,IAAIgH,YAAY,GAAGpF,QAAQ,CAACqF,SAAS,CAAC,UAAArC,OAAO;cAAA,OAAKA,OAAO,CAACsC,EAAE,IAAIrC,MAAM,CAAChF,CAAC,IAAI+E,OAAO,CAACuC,EAAE,IAAItC,MAAM,CAAC7E,CAAC,IAAI4E,OAAO,CAACwC,EAAE,IAAIrC,MAAM,CAAClF,CAAC,IAAI+E,OAAO,CAACyC,EAAE,IAAItC,MAAM,CAAC/E,CAAC,IAAM4E,OAAO,CAACsC,EAAE,IAAInC,MAAM,CAAClF,CAAC,IAAI+E,OAAO,CAACuC,EAAE,IAAIpC,MAAM,CAAC/E,CAAC,IAAI4E,OAAO,CAACwC,EAAE,IAAIvC,MAAM,CAAChF,CAAC,IAAI+E,OAAO,CAACyC,EAAE,IAAIxC,MAAM,CAAC7E,CAAE;YAAA,EAAC;YAElQ,IAAGgH,YAAY,KAAK,CAAC,CAAC,EAAE;cACpBpF,QAAQ,CAACsE,MAAM,CAACc,YAAY,EAAE,CAAC,CAAC;cAChCnC,MAAM,GAAGE,MAAM;cAAC;YAEpB;YAEA,IAAGtF,MAAM,CAACqH,IAAI,CAAC,UAAA1E,KAAK;cAAA,OAAIA,KAAK,CAACvC,CAAC,IAAIkF,MAAM,CAAClF,CAAC,IAAIuC,KAAK,CAACpC,CAAC,IAAI+E,MAAM,CAAC/E,CAAC;YAAA,EAAC,KAAKjD,SAAS,EAC7E0C,MAAM,CAAC+B,IAAI,CAACuD,MAAM,CAAC;;YAEvB;YACA,IAAIH,OAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACyE,MAAM,CAAChF,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,EAAE+E,MAAM,CAAClF,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,CAAC;YAC1E4B,QAAQ,CAACJ,IAAI,CAACoD,OAAO,CAAC;YAEtBC,MAAM,GAAGE,MAAM;UACnB,CAAC;UAnBD,KAAI,IAAIxB,CAAC,GAAG,CAAC,EAAEzG,QAAM,GAAG8J,QAAQ,CAAC9J,MAAM,EAAEyG,CAAC,GAAGzG,QAAM,EAAEyG,CAAC,EAAE;YAAA,IAAA+D,IAAA,GAAAP,MAAA;YAAA,IAAAO,IAAA,iBAQhD;UAAS;;UAajB;UACA,IAAIC,cAAc,GAAG,IAAIvK,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACwG,QAAQ,CAACA,QAAQ,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAAC+C,CAAC,EAAE+G,QAAQ,CAACA,QAAQ,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAACkD,CAAC,EAAE4G,QAAQ,CAAC,CAAC,CAAC,CAAC/G,CAAC,EAAE+G,QAAQ,CAAC,CAAC,CAAC,CAAC5G,CAAC,CAAC;UAEzI,IAAIgH,YAAY,GAAGpF,QAAQ,CAACqF,SAAS,CAAC,UAAArC,OAAO;YAAA,OAAKA,OAAO,CAACsC,EAAE,IAAIK,cAAc,CAACL,EAAE,IAAItC,OAAO,CAACuC,EAAE,IAAII,cAAc,CAACJ,EAAE,IAAIvC,OAAO,CAACwC,EAAE,IAAIG,cAAc,CAACH,EAAE,IAAIxC,OAAO,CAACyC,EAAE,IAAIE,cAAc,CAACF,EAAE,IAAMzC,OAAO,CAACsC,EAAE,IAAIK,cAAc,CAACH,EAAE,IAAIxC,OAAO,CAACuC,EAAE,IAAII,cAAc,CAACF,EAAE,IAAIzC,OAAO,CAACwC,EAAE,IAAIG,cAAc,CAACL,EAAE,IAAItC,OAAO,CAACyC,EAAE,IAAIE,cAAc,CAACJ,EAAG;UAAA,EAAC;UAC1U,IAAGH,YAAY,KAAKjK,SAAS,EACzB6E,QAAQ,CAACJ,IAAI,CAAC+F,cAAc,CAAC;QACrC,CAAC;QAlCD,KAAI,IAAI7E,EAAC,GAAG,CAAC,EAAE5F,OAAM,GAAG4J,QAAQ,CAACC,KAAK,CAAC7J,MAAM,EAAE4F,EAAC,GAAG5F,OAAM,EAAE4F,EAAC,EAAE;UAAAmE,KAAA;QAAA;MAmClE;IACJ;EAAC,SAAAxE,GAAA;IAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;EAAA;IAAAP,SAAA,CAAAS,CAAA;EAAA;EAED,IAAI,CAAC/C,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EAEzB,IAAG4E,cAAc,EAAE;IACf,IAAIC,MAAM,GAAG,IAAI,CAAC5D,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAACC,SAAS,CAAChB,MAAM,CAACN,IAAI,CAAC;IAChEA,IAAI,CAACM,MAAM,GAAGA,MAAM;EACxB;EAEA,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpJ,cAAcA,CAAA,EAAG;EAC7B,IAAIoJ,MAAM,GAAG,IAAI,CAACnJ,MAAM,CAACY,IAAI,KAAK,MAAM,IAAI,IAAI,CAACZ,MAAM,CAACY,IAAI,KAAK,WAAW,GAAG,IAAI,CAACZ,MAAM,CAACmJ,MAAM,GAAG,IAAI,CAACnJ,MAAM,CAAC6I,IAAI,CAACM,MAAM;EAE3H,OAAO,IAAIzJ,MAAM,CAAC2C,IAAI,CAAC+H,SAAS,CAACjB,MAAM,CAACkB,GAAG,CAAC9H,CAAC,EAAE4G,MAAM,CAACkB,GAAG,CAAC3H,CAAC,EAAEyG,MAAM,CAACmB,GAAG,CAAC/H,CAAC,GAAG4G,MAAM,CAACkB,GAAG,CAAC9H,CAAC,EAAE4G,MAAM,CAACmB,GAAG,CAAC5H,CAAC,GAAGyG,MAAM,CAACkB,GAAG,CAAC3H,CAAC,CAAC;AAC1H;;;;;;;;;;;;;;;;;;;;AC7LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS7B,SAASA,CAAA,EAAc;EAAA,IAAboB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACM,OAAO;AACvB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpB,WAAWA,CAAA,EAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACuC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,SAASA,CAAA,EAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAIO,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;;EAEjB;EACA,IAAIlC,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACwC,YAAY,GAAG,IAAI,CAACxC,MAAM,CAACyC,OAAO;EACzEL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,aAAa,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO;EAC1E;EACA;EACA,IAAIK,QAAQ,GAAG,IAAI,CAACjD,MAAM,CAACiD,QAAQ;EACnC,IAAGA,QAAQ,KAAK,CAAC,EAAE;IAAA,IAAAuB,SAAA,GAAAC,0BAAA,CACE,IAAI,CAACzE,MAAM,CAACqE,IAAI,CAAClC,MAAM;MAAAuC,KAAA;IAAA;MAAxC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA0C;QAAA,IAAlCC,KAAK,GAAAJ,KAAA,CAAAtF,KAAA;QACT,IAAI8D,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,IAAI,CAAC9C,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEoC,KAAK,CAACvC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEuC,KAAK,CAACpC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACjJhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACuC,CAAC,EAAE,IAAI,CAACvC,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;QAC7If,MAAM,CAAC+B,IAAI,CAAChB,MAAM,CAACK,SAAS,CAAC,CAAC,CAAC;MACnC;IAAC,SAAAwB,GAAA;MAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;IAAA;MAAAP,SAAA,CAAAS,CAAA;IAAA;EACL;EACA;EAAA,KACK;IAAA,IAAAC,UAAA,GAAAT,0BAAA,CACgB,IAAI,CAACzE,MAAM,CAACqE,IAAI,CAAClC,MAAM;MAAAgD,MAAA;IAAA;MAAxC,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAA0C;QAAA,IAAlCC,MAAK,GAAAK,MAAA,CAAA/F,KAAA;QACT+C,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwC,MAAK,CAACvC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEuC,MAAK,CAACpC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC,CAAC;MACxH;IAAC,SAAAqC,GAAA;MAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;IAAA;MAAAG,UAAA,CAAAD,CAAA;IAAA;EACL;;EAEA;EACA,KAAI,IAAIG,CAAC,GAAG,CAAC,EAAE5F,MAAM,GAAG2C,MAAM,CAAC3C,MAAM,EAAE4F,CAAC,GAAG5F,MAAM,EAAE4F,CAAC,EAAE,EAAE;IACpD,IAAGA,CAAC,GAAC,CAAC,GAAG5F,MAAM,EACX8E,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACiD,CAAC,CAAC,CAAC7C,CAAC,EAAEJ,MAAM,CAACiD,CAAC,CAAC,CAAC1C,CAAC,EAAEP,MAAM,CAACiD,CAAC,GAAC,CAAC,CAAC,CAAC7C,CAAC,EAAEJ,MAAM,CAACiD,CAAC,GAAC,CAAC,CAAC,CAAC1C,CAAC,CAAC,CAAC;EACnG;EACA;EACA,IAAG,IAAI,CAAC1C,MAAM,CAACuK,SAAS,EAAE;IACtB,IAAIC,IAAI,GAAGrI,MAAM,CAAC3C,MAAM,GAAG,CAAC;IAC5B8E,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACqI,IAAI,CAAC,CAACjI,CAAC,EAAEJ,MAAM,CAACqI,IAAI,CAAC,CAAC9H,CAAC,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACI,CAAC,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAACO,CAAC,CAAC,CAAC;EACjG;EAEA,IAAI,CAACR,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EAEzB,OAAO,IAAI;AACf;AAAC;;;;;;;;;;;;;;;;;AC3FD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASzD,SAASA,CAAA,EAAc;EAAA,IAAboB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACM,OAAO;AACvB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpB,WAAWA,CAAA,EAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACuC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,SAASA,CAAA,EAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAIO,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;;EAEjB;EACAnC,MAAM,GAAG,CACL,IAAI,CAACnC,MAAM,CAACyK,UAAU,CAAC,CAAC,EACxB,IAAI,CAACzK,MAAM,CAAC0K,WAAW,CAAC,CAAC,EACzB,IAAI,CAAC1K,MAAM,CAAC2K,cAAc,CAAC,CAAC,EAC5B,IAAI,CAAC3K,MAAM,CAAC4K,aAAa,CAAC,CAAC,CAC9B;;EAED;EACA,KAAI,IAAIxF,CAAC,GAAG,CAAC,EAAE5F,MAAM,GAAG2C,MAAM,CAAC3C,MAAM,EAAE4F,CAAC,GAAG5F,MAAM,EAAE4F,CAAC,EAAE,EAAE;IACpD,IAAIyF,SAAS,GAAGzF,CAAC,GAAG,CAAC,GAAGjD,MAAM,CAACiD,CAAC,GAAG,CAAC,CAAC,GAAGjD,MAAM,CAAC2I,KAAK,CAAC,CAAC,CAAC,CAAC;MACpDC,SAAS,GAAG3F,CAAC,GAAG5F,MAAM,GAAG,CAAC,GAAG2C,MAAM,CAACiD,CAAC,GAAG,CAAC,CAAC,GAAGjD,MAAM,CAAC,CAAC,CAAC;IAE1DmC,QAAQ,CAACJ,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACiD,CAAC,CAAC,CAAC7C,CAAC,EAAEJ,MAAM,CAACiD,CAAC,CAAC,CAAC1C,CAAC,EAAEqI,SAAS,CAACxI,CAAC,EAAEwI,SAAS,CAACrI,CAAC,CAAC,CAAC;IACvFP,MAAM,CAACiD,CAAC,CAAC,CAACuB,YAAY,GAAG,IAAIjH,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC+H,SAAS,CAACtI,CAAC,EAAEsI,SAAS,CAACnI,CAAC,EAAEqI,SAAS,CAACxI,CAAC,EAAEwI,SAAS,CAACrI,CAAC,CAAC;;IAGjG;AACR;AACA;AACA;AACA;AACA;AACA;AACA;EACI;;EAEA,IAAI,CAACR,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EAEzB,OAAO,IAAI;AACf;AAAC;;;;;;;;;;;;;;;;;;;;;ACtFD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASzD,SAASA,CAAA,EAAc;EAAA,IAAboB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EACb,IAAG,CAACK,GAAG,IAAIA,GAAG,KAAKA,GAAG,CAAC+I,cAAc,IAAI,CAAC,IAAI/I,GAAG,CAAC+I,cAAc,IAAItL,MAAM,CAACgE,IAAI,CAACuH,gBAAgB,CAAC,EAC7F,OAAO,IAAI,CAAC/I,OAAO;EAEvB,IAAIC,MAAM,GAAG,EAAE;EAAC,IAAAqC,SAAA,GAAAC,0BAAA,CACC,IAAI,CAACvC,OAAO;IAAAwC,KAAA;EAAA;IAA7B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA+B;MAAA,IAAvBC,KAAK,GAAAJ,KAAA,CAAAtF,KAAA;MACT,IAAGM,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAClJ,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAEoC,KAAK,CAACvC,CAAC,EAAEuC,KAAK,CAACpC,CAAC,CAAC,IAAIT,GAAG,CAAC+I,cAAc,EAC/F7I,MAAM,CAAC+B,IAAI,CAACY,KAAK,CAAC;IAC1B;;IAEA;EAAA,SAAAC,GAAA;IAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;EAAA;IAAAP,SAAA,CAAAS,CAAA;EAAA;EACA,IAAIX,QAAQ,GAAG,IAAI,CAACxD,WAAW,CAACmB,GAAG,CAAC;EAAC,IAAAiD,UAAA,GAAAT,0BAAA,CAElBH,QAAQ;IAAAa,MAAA;EAAA;IAA3B,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAA6B;MAAA,IAArByC,OAAO,GAAAnC,MAAA,CAAA/F,KAAA;MACX,IAAGM,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAClJ,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAE4E,OAAO,CAACsC,EAAE,EAAEtC,OAAO,CAACuC,EAAE,CAAC,GAAG5H,GAAG,CAAC+I,cAAc,EACpG7I,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgF,OAAO,CAACsC,EAAE,EAAEtC,OAAO,CAACuC,EAAE,CAAC,CAAC;MAE9D,IAAGnK,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAClJ,GAAG,CAACuB,MAAM,CAACjB,CAAC,EAAEN,GAAG,CAACuB,MAAM,CAACd,CAAC,EAAE4E,OAAO,CAACwC,EAAE,EAAExC,OAAO,CAACyC,EAAE,CAAC,GAAG9H,GAAG,CAAC+I,cAAc,EACpG7I,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACgF,OAAO,CAACwC,EAAE,EAAExC,OAAO,CAACyC,EAAE,CAAC,CAAC;IAClE;EAAC,SAAAhF,GAAA;IAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;EAAA;IAAAG,UAAA,CAAAD,CAAA;EAAA;EAED,OAAO9C,MAAM;AACjB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASrB,WAAWA,CAAA,EAAc;EAAA,IAAbmB,GAAG,GAAA1C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACnC,IAAG,CAAC,IAAI,CAACqC,MAAM,EACX,OAAO,EAAE;EACb,IAAG,CAACK,GAAG,IAAIA,GAAG,KAAKA,GAAG,CAAC+I,cAAc,IAAI,CAAC,IAAI/I,GAAG,CAAC+I,cAAc,IAAItL,MAAM,CAACgE,IAAI,CAACuH,gBAAgB,CAAC,EAC7F,OAAO,IAAI,CAAC9G,SAAS;EAEzB,IAAIG,QAAQ,GAAG,EAAE;EAAC,IAAAkC,UAAA,GAAA/B,0BAAA,CACC,IAAI,CAACN,SAAS;IAAAsC,MAAA;EAAA;IAAjC,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAAmC;MAAA,IAA3ByC,OAAO,GAAAb,MAAA,CAAArH,KAAA;MACX,IAAGM,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC+E,YAAY,CAAC9D,OAAO,EAAErF,GAAG,CAACoJ,oBAAoB,CAAC,EAAE;QACvE/G,QAAQ,CAACJ,IAAI,CAACoD,OAAO,CAAC;MAC1B;IACJ;EAAC,SAAAvC,GAAA;IAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;EAAA;IAAAyB,UAAA,CAAAvB,CAAA;EAAA;EAED,OAAOX,QAAQ;AACnB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASvD,SAASA,CAAA,EAAG;EAAA,IAAAnC,KAAA;EACxB,IAAG,CAAC,IAAI,CAACgD,MAAM,EACX,OAAO,IAAI;EAEf,IAAIO,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;;EAEjB;EACA,IAAIlC,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACuC,CAAC;EACxBH,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC;EAExB,IAAI4I,UAAU,GAAG,KAAK;EACtB,IAAIC,WAAW,GAAG,EAAE;EACpB,IAAIC,SAAS,GAAG,EAAE;;EAElB;EACA,KAAI,IAAIpG,CAAC,GAAG,CAAC,EAAEQ,OAAO,GAAG,IAAI,CAAC5F,MAAM,CAACyL,KAAK,CAAC1J,IAAI,CAACvC,MAAM,EAAE4F,CAAC,GAAGQ,OAAO,EAAER,CAAC,EAAE,EAAE;IACtE,IAAIsG,GAAG,GAAG,IAAI,CAAC1L,MAAM,CAACyL,KAAK,CAAC1J,IAAI,CAACqD,CAAC,CAAC;;IAEnC;IACA,KAAI,IAAIa,CAAC,GAAG,CAAC,EAAEC,OAAO,GAAGwF,GAAG,CAAClM,MAAM,EAAEyG,CAAC,GAAGC,OAAO,EAAED,CAAC,EAAE,EAAE;MACnD,IAAI0F,IAAI,GAAGD,GAAG,CAACzF,CAAC,CAAC;;MAEjB;MACA,IAAI2F,SAAS,GAAKxG,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC/D,cAAc,CAACwK,QAAQ,CAAC,IAAI,CAAC7L,MAAM,CAACyL,KAAK,CAAC1J,IAAI,CAACqD,CAAC,GAAC,CAAC,CAAC,CAACa,CAAC,CAAC,CAACyC,KAAK,CAAC,IAAI,IAAI,CAACrH,cAAc,CAACwK,QAAQ,CAACF,IAAI,CAACjD,KAAK,CAAC,IAAMtD,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC/D,cAAc,CAACwK,QAAQ,CAACF,IAAI,CAACjD,KAAK,CAAE,GAAI,IAAI,GAAG,KAAK;MAClN,IAAIoD,QAAQ,GAAK7F,CAAC,GAAG,CAAC,IAAI,IAAI,CAAC5E,cAAc,CAACwK,QAAQ,CAAC,IAAI,CAAC7L,MAAM,CAACyL,KAAK,CAAC1J,IAAI,CAACqD,CAAC,CAAC,CAACa,CAAC,GAAC,CAAC,CAAC,CAACyC,KAAK,CAAC,IAAI,IAAI,CAACrH,cAAc,CAACwK,QAAQ,CAACF,IAAI,CAACjD,KAAK,CAAC,IAAMzC,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC5E,cAAc,CAACwK,QAAQ,CAACF,IAAI,CAACjD,KAAK,CAAE,GAAI,IAAI,GAAG,KAAK;;MAEjN;MACA,IAAIqD,SAAQ,GAAG,KAAK;MACpB,IAAGP,SAAS,CAAChM,MAAM,IAAIyG,CAAC,EACpBuF,SAAS,CAACvF,CAAC,CAAC,GAAG,EAAE,CAAC,KACjB,IAAGuF,SAAS,CAACvF,CAAC,CAAC,CAACzG,MAAM,GAAG,CAAC,EAC3BuM,SAAQ,GAAGP,SAAS,CAACvF,CAAC,CAAC,CAACuF,SAAS,CAACvF,CAAC,CAAC,CAACzG,MAAM,GAAG,CAAC,CAAC;;MAEpD;MACA,IAAGsM,QAAQ,EAAE;QACT,IAAGC,SAAQ,IAAIA,SAAQ,CAACrJ,CAAC,GAAGqJ,SAAQ,CAACC,MAAM,IAAI5G,CAAC,EAC5C2G,SAAQ,CAACC,MAAM,EAAE,CAAC,KACjB;UACDR,SAAS,CAACvF,CAAC,CAAC,CAAC/B,IAAI,CAAC;YACd3B,CAAC,EAAEoJ,IAAI,CAACpJ,CAAC;YACTG,CAAC,EAAEiJ,IAAI,CAACjJ,CAAC;YACTsJ,MAAM,EAAE;UACZ,CAAC,CAAC;QACN;MACJ;;MAEA;MACA,IAAGJ,SAAS,EAAE;QACV,IAAGN,UAAU,EACTA,UAAU,CAACW,KAAK,EAAE,CAAC,KAEnBX,UAAU,GAAG;UACT/I,CAAC,EAAEoJ,IAAI,CAACpJ,CAAC;UACTG,CAAC,EAAEiJ,IAAI,CAACjJ,CAAC;UACTuJ,KAAK,EAAE;QACX,CAAC;QACL;MACJ;MAEA,IAAGX,UAAU,EAAE;QACX,IAAI/I,CAAC,GAAG+I,UAAU,CAAC/I,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;QAClF,IAAIG,EAAC,GAAG4I,UAAU,CAAC5I,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACyL,KAAK,CAACU,UAAU,GAAG,IAAI,CAACnM,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;QACnF,IAAI4E,OAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACP,CAAC,EAAEG,EAAC,EAAEH,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,EAAC,CAAC;QACpH4B,QAAQ,CAACJ,IAAI,CAACoD,OAAO,CAAC;QACtBiE,WAAW,CAACrH,IAAI,CAACoD,OAAO,CAAC;QACzBnF,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,CAAC,EAAEG,EAAC,CAAC,CAAC;QACxCP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,EAAC,CAAC,CAAC;QAC9G4I,UAAU,GAAG,KAAK;MACtB;IACJ;;IAEA;IACA,IAAGA,UAAU,EAAE;MACX,IAAI/I,EAAC,GAAG+I,UAAU,CAAC/I,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;MAClF,IAAIG,GAAC,GAAG4I,UAAU,CAAC5I,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACyL,KAAK,CAACU,UAAU,GAAG,IAAI,CAACnM,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;MACnF,IAAI4E,QAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACP,EAAC,EAAEG,GAAC,EAAEH,EAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,GAAC,CAAC;MACpH4B,QAAQ,CAACJ,IAAI,CAACoD,QAAO,CAAC;MACtBiE,WAAW,CAACrH,IAAI,CAACoD,QAAO,CAAC;MACzBnF,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,EAAC,EAAEG,GAAC,CAAC,CAAC;MACxCP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,EAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,GAAC,CAAC,CAAC;MAC9G4I,UAAU,GAAG,KAAK;IACtB;EACJ;;EAEA;EAAA,IAAApE,UAAA,GAAAzC,0BAAA,CACgB,IAAI,CAACzE,MAAM,CAACyL,KAAK,CAAC1J,IAAI,CAAC,IAAI,CAAC/B,MAAM,CAACyL,KAAK,CAAC1J,IAAI,CAACvC,MAAM,GAAG,CAAC,CAAC;IAAA2H,MAAA;EAAA;IAAzE,KAAAD,UAAA,CAAAvC,CAAA,MAAAwC,MAAA,GAAAD,UAAA,CAAAtC,CAAA,IAAAC,IAAA,GAA2E;MAAA,IAAnE8G,KAAI,GAAAxE,MAAA,CAAA/H,KAAA;MACR,IAAG,IAAI,CAACiC,cAAc,CAACwK,QAAQ,CAACF,KAAI,CAACjD,KAAK,CAAC,EAAE;QACzC,IAAG4C,UAAU,EACTA,UAAU,CAACW,KAAK,EAAE,CAAC,KAEnBX,UAAU,GAAG;UACT/I,CAAC,EAAEoJ,KAAI,CAACpJ,CAAC;UACTG,CAAC,EAAEiJ,KAAI,CAACjJ,CAAC,GAAG,CAAC;UACbuJ,KAAK,EAAE;QACX,CAAC;QACL;MACJ;MAEA,IAAGX,UAAU,EAAE;QACX,IAAI/I,GAAC,GAAG+I,UAAU,CAAC/I,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;QAClF,IAAIG,GAAC,GAAG4I,UAAU,CAAC5I,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACyL,KAAK,CAACU,UAAU,GAAG,IAAI,CAACnM,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;QACnF,IAAI4E,SAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACP,GAAC,EAAEG,GAAC,EAAEH,GAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,GAAC,CAAC;QACpH4B,QAAQ,CAACJ,IAAI,CAACoD,SAAO,CAAC;QACtBiE,WAAW,CAACrH,IAAI,CAACoD,SAAO,CAAC;QACzBnF,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,GAAC,EAAEG,GAAC,CAAC,CAAC;QACxCP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,GAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,GAAC,CAAC,CAAC;QAC9G4I,UAAU,GAAG,KAAK;MACtB;IACJ;;IAEA;EAAA,SAAAvG,GAAA;IAAAmC,UAAA,CAAAlC,CAAA,CAAAD,GAAA;EAAA;IAAAmC,UAAA,CAAAjC,CAAA;EAAA;EACA,IAAGqG,UAAU,EAAE;IACX,IAAI/I,GAAC,GAAG+I,UAAU,CAAC/I,CAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;IAClF,IAAIG,GAAC,GAAG4I,UAAU,CAAC5I,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACyL,KAAK,CAACU,UAAU,GAAG,IAAI,CAACnM,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;IACnF,IAAI4E,SAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACP,GAAC,EAAEG,GAAC,EAAEH,GAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,GAAC,CAAC;IACpH4B,QAAQ,CAACJ,IAAI,CAACoD,SAAO,CAAC;IACtBiE,WAAW,CAACrH,IAAI,CAACoD,SAAO,CAAC;IACzBnF,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,GAAC,EAAEG,GAAC,CAAC,CAAC;IACxCP,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,GAAC,GAAG,IAAI,CAACvC,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAG,IAAI,CAAClM,MAAM,CAAC8D,MAAM,GAAGwH,UAAU,CAACW,KAAK,EAAEvJ,GAAC,CAAC,CAAC;IAC9G4I,UAAU,GAAG,KAAK;EACtB;;EAEA;EACA,IAAIS,QAAQ,GAAG,KAAK;EACpB,IAAIK,mBAAmB,GAAG,EAAE;EAAC,IAAAhF,UAAA,GAAA3C,0BAAA,CACd,IAAI,CAACzE,MAAM,CAACyL,KAAK,CAAC1J,IAAI;IAAAsF,MAAA;EAAA;IAArC,KAAAD,UAAA,CAAAzC,CAAA,MAAA0C,MAAA,GAAAD,UAAA,CAAAxC,CAAA,IAAAC,IAAA,GAAuC;MAAA,IAA/B6G,IAAG,GAAArE,MAAA,CAAAjI,KAAA;MACP,IAAIuM,MAAI,GAAGD,IAAG,CAACA,IAAG,CAAClM,MAAM,GAAG,CAAC,CAAC;;MAE9B;MACA,IAAG,IAAI,CAAC6B,cAAc,CAACwK,QAAQ,CAACF,MAAI,CAACjD,KAAK,CAAC,EAAE;QACzC,IAAGqD,QAAQ,EAAE;UACTA,QAAQ,CAACC,MAAM,EAAE;QACrB,CAAC,MACI;UACDD,QAAQ,GAAG;YACPxJ,CAAC,EAAEoJ,MAAI,CAACpJ,CAAC,GAAG,CAAC;YACbG,CAAC,EAAEiJ,MAAI,CAACjJ,CAAC;YACTsJ,MAAM,EAAE;UACZ,CAAC;QACL;QAEA;MACJ;MAEA,IAAGD,QAAQ,EAAE;QACTK,mBAAmB,CAAClI,IAAI,CAAC6H,QAAQ,CAAC;QAClCA,QAAQ,GAAG,KAAK;MACpB;IACJ;EAAC,SAAAhH,GAAA;IAAAqC,UAAA,CAAApC,CAAA,CAAAD,GAAA;EAAA;IAAAqC,UAAA,CAAAnC,CAAA;EAAA;EAEDuG,SAAS,CAACtH,IAAI,CAACkI,mBAAmB,CAAC;;EAEnC;EACA,SAAAC,EAAA,MAAAC,UAAA,GAAkBd,SAAS,EAAAa,EAAA,GAAAC,UAAA,CAAA9M,MAAA,EAAA6M,EAAA,IAAE;IAAzB,IAAIE,MAAM,GAAAD,UAAA,CAAAD,EAAA;IACV,IAAG,CAACE,MAAM,EACN;IAAS,IAAAzE,UAAA,GAAArD,0BAAA,CAEO8H,MAAM;MAAAxE,MAAA;IAAA;MAAA,IAAAwB,KAAA,YAAAA,MAAA,EAAE;QAAA,IAApBwC,QAAQ,GAAAhE,MAAA,CAAA3I,KAAA;QACZ,IAAImD,CAAC,GAAGwJ,QAAQ,CAACxJ,CAAC,GAAG3D,KAAI,CAACoB,MAAM,CAACyL,KAAK,CAACS,SAAS,GAAGtN,KAAI,CAACoB,MAAM,CAAC8D,MAAM,GAAG1B,MAAM,CAACG,CAAC;QAChF,IAAIsH,EAAE,GAAGkC,QAAQ,CAACrJ,CAAC,GAAG9D,KAAI,CAACoB,MAAM,CAACyL,KAAK,CAACU,UAAU,GAAGvN,KAAI,CAACoB,MAAM,CAACoE,MAAM,GAAGhC,MAAM,CAACM,CAAC;QAClF,IAAIqH,EAAE,GAAGF,EAAE,GAAGjL,KAAI,CAACoB,MAAM,CAACyL,KAAK,CAACU,UAAU,GAAGvN,KAAI,CAACoB,MAAM,CAACoE,MAAM,GAAG2H,QAAQ,CAACC,MAAM;QACjF,IAAI1E,OAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACP,CAAC,EAAEsH,EAAE,EAAEtH,CAAC,EAAEwH,EAAE,CAAC;QAChDzF,QAAQ,CAACJ,IAAI,CAACoD,OAAO,CAAC;;QAEtB;QACA,IAAG,CAACnF,MAAM,CAACqK,MAAM,CAAC,UAAA1H,KAAK;UAAA,OAAIA,KAAK,CAACvC,CAAC,IAAIA,CAAC,IAAIuC,KAAK,CAACpC,CAAC,IAAImH,EAAE;QAAA,EAAC,EACrD1H,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,CAAC,EAAEG,CAAC,CAAC,CAAC;QAE5C,IAAG,CAACP,MAAM,CAACqK,MAAM,CAAC,UAAA1H,KAAK;UAAA,OAAIA,KAAK,CAACvC,CAAC,IAAIA,CAAC,IAAIuC,KAAK,CAACpC,CAAC,IAAIqH,EAAE;QAAA,EAAC,EACrD5H,MAAM,CAAC+B,IAAI,CAAC,IAAIxE,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACC,CAAC,EAAEG,CAAC,CAAC,CAAC;;QAE5C;QAAA,IAAA+J,UAAA,GAAAhI,0BAAA,CAC6B8G,WAAW;UAAAmB,MAAA;QAAA;UAAxC,KAAAD,UAAA,CAAA9H,CAAA,MAAA+H,MAAA,GAAAD,UAAA,CAAA7H,CAAA,IAAAC,IAAA,GAA0C;YAAA,IAAlC8H,iBAAiB,GAAAD,MAAA,CAAAtN,KAAA;YACrB,IAAGkI,OAAO,CAACsC,EAAE,IAAI+C,iBAAiB,CAAC/C,EAAE,IAAItC,OAAO,CAACsC,EAAE,IAAI+C,iBAAiB,CAAC7C,EAAE,IAAIxC,OAAO,CAACwC,EAAE,IAAI6C,iBAAiB,CAAC/C,EAAE,IAAItC,OAAO,CAACwC,EAAE,IAAI6C,iBAAiB,CAAC7C,EAAE,EACnJ;YAEJ,IAAGxC,OAAO,CAACuC,EAAE,IAAI8C,iBAAiB,CAAC9C,EAAE,IAAIvC,OAAO,CAACuC,EAAE,IAAI8C,iBAAiB,CAAC5C,EAAE,IAAIzC,OAAO,CAACyC,EAAE,IAAI4C,iBAAiB,CAAC9C,EAAE,IAAIvC,OAAO,CAACyC,EAAE,IAAI4C,iBAAiB,CAAC5C,EAAE,EACnJ;YAEJ,IAAIjF,KAAK,GAAG,IAAIpF,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;YACnC,IAAG5C,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAACU,OAAO,EAAEqF,iBAAiB,EAAE7H,KAAK,CAAC,EAAE;cACrE3C,MAAM,CAAC+B,IAAI,CAACY,KAAK,CAAC;YACtB;UACJ;QAAC,SAAAC,GAAA;UAAA0H,UAAA,CAAAzH,CAAA,CAAAD,GAAA;QAAA;UAAA0H,UAAA,CAAAxH,CAAA;QAAA;MACL,CAAC;MA3BD,KAAA6C,UAAA,CAAAnD,CAAA,MAAAoD,MAAA,GAAAD,UAAA,CAAAlD,CAAA,IAAAC,IAAA;QAAA0E,KAAA;MAAA;IA2BC,SAAAxE,GAAA;MAAA+C,UAAA,CAAA9C,CAAA,CAAAD,GAAA;IAAA;MAAA+C,UAAA,CAAA7C,CAAA;IAAA;EACL;EAEA,IAAI,CAAC/C,OAAO,GAAGC,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EACzB,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAShD,iBAAiBA,CAAA,EAAa;EAAA,IAAZsL,KAAK,GAAArN,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EACxC,IAAI,CAAC8B,cAAc,GAAGuL,KAAK;EAC3B,OAAO,IAAI;AACf;;;;;;;;;;;;;;;ACjSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS3L,eAAeA,CAAC4L,KAAK,EAAE;EACnC,IAAI,CAACpM,YAAY,GAAGoM,KAAK;EACzB,IAAI,CAAC7L,MAAM,GAAG6L,KAAK,GAAG,KAAK,GAAG,IAAI;EAElC,IAAI,CAAC9L,SAAS,CAAC,CAAC;EAChB,OAAO,IAAI;AACf;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS+L,QAAQA,CAAA,EAAY;EAAA,IAAX/I,KAAK,GAAAxE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC9B,IAAI,CAACwE,KAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC2J,SAAS,CAAChJ,KAAK,CAAC;EAC/CrE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAAC,IAAI,CAAC6J,IAAI,EAAE,IAAI,CAACxJ,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACkJ,QAAQ,CAAC;EAC/F,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,WAAWA,CAAA,EAAY;EAAA,IAAXnJ,KAAK,GAAAxE,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EACjC,IAAI,CAACwE,KAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC2J,SAAS,CAACrN,MAAM,CAACgE,IAAI,CAACyJ,QAAQ,CAACpJ,KAAK,CAAC,CAAC;EACrErE,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAAC,IAAI,CAAC6J,IAAI,EAAE,IAAI,CAACxJ,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACkJ,QAAQ,CAAC;EAC/F,OAAO,IAAI;AACf;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,IAAIA,CAAA,EAAe;EAAA,IAAd9N,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAC7B,IAAI8N,mBAAmB;EACvB,IAAIC,cAAc;EAClB,IAAIC,aAAa;EACjB,IAAIC,eAAe,GAAG,IAAI,CAACP,QAAQ;EACnC,IAAIQ,QAAQ,GAAGnO,OAAO,CAACmO,QAAQ,GAAGnO,OAAO,CAACmO,QAAQ,GAAG,KAAK;EAC1D,IAAIC,SAAS,GAAGC,WAAW,CAACC,GAAG,CAAC,CAAC;EACjC,IAAIC,KAAK,GAAG;IACRC,MAAM,EAAE,MAAM;IACdC,IAAI,EAAE,CAAC;IACPC,mBAAmB,EAAE,CAAC;IACtBC,gBAAgB,EAAE,CAAC;IACnB3J,QAAQ,EAAE,CAAC;IACX4J,IAAI,EAAE;EACV,CAAC;;EAED;EACA,IAAG,IAAI,CAAC3I,UAAU,IAAI,IAAI,CAACA,UAAU,CAAC7E,WAAW,EAAE;IAC/C,IAAIyN,cAAa,GAAG,EAAE;IACtBzO,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC+H,kBAAkB,CAAC,IAAI,CAACpB,IAAI,EAAE,IAAI,CAACzH,UAAU,CAAC7E,WAAW,CAACR,SAAS,EAAEiO,cAAa,CAAC;IAC1G,IAAGA,cAAa,CAAC3O,MAAM,KAAK,CAAC,EACzB6N,mBAAmB,GAAGc,cAAa,CAAC,CAAC,CAAC,CAAC,KACtC,IAAGA,cAAa,CAAC3O,MAAM,GAAG,CAAC,EAAE;MAAA,IAAAgF,SAAA,GAAAC,0BAAA,CACN0J,cAAa;QAAAzJ,KAAA;MAAA;QAArC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAuC;UAAA,IAA/B8B,YAAY,GAAAjC,KAAA,CAAAtF,KAAA;UAChB,IAAIiP,QAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEiE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,CAAC;UACzG,IAAG2L,QAAQ,GAAGb,eAAe,EAAE;YAC3BA,eAAe,GAAGa,QAAQ;YAC1BhB,mBAAmB,GAAG1G,YAAY;UACtC;QACJ;MAAC,SAAA5B,GAAA;QAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;MAAA;QAAAP,SAAA,CAAAS,CAAA;MAAA;IACL;IACA;IAAA,KACK,IAAG3F,OAAO,CAACgP,MAAM,EAAC;MACnB,IAAID,SAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEpD,OAAO,CAACgP,MAAM,CAAC/L,CAAC,EAAEjD,OAAO,CAACgP,MAAM,CAAC5L,CAAC,CAAC;MAC7G;MACA,IAAG,IAAI,CAACuK,QAAQ,GAAGoB,SAAQ,EAAE;QACzBb,eAAe,GAAGa,SAAQ;QAC1BhB,mBAAmB,GAAG/N,OAAO,CAACgP,MAAM;MACxC;IACJ;EACJ;;EAEA;EACA,IAAG,CAAChP,OAAO,CAACiP,OAAO,EAAE;IACjB,IAAG,IAAI,CAAChJ,UAAU,EACdjG,OAAO,CAACiP,OAAO,GAAG,IAAI,CAAChJ,UAAU,CAACgD,aAAa,CAAC,KAEhD,OAAO4F,aAAa;EAC5B;EAAC,IAAAjJ,UAAA,GAAAT,0BAAA,CAEiBnF,OAAO,CAACiP,OAAO;IAAApJ,MAAA;EAAA;IAAjC,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAAmC;MAAA,IAA3B7E,MAAM,GAAAmF,MAAA,CAAA/F,KAAA;MACV,IAAI0H,GAAG;QAAEpG,WAAW;QAAE8N,wBAAwB,GAAG,EAAE;QAAEC,UAAU,GAAG,KAAK;MAEvE,IAAGzO,MAAM,CAACY,IAAI,KAAK,MAAM,IAAIZ,MAAM,CAACY,IAAI,KAAK,WAAW,EACpDkG,GAAG,GAAG9G,MAAM,CAAC8B,YAAY,CAAC,KAE1BgF,GAAG,GAAG9G,MAAM,CAAC+B,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;MAEzC6H,KAAK,CAACG,mBAAmB,EAAE;;MAE3B;MACA,IAAGP,QAAQ,EAAE;QACT/M,WAAW,GAAGoG,GAAG,CAAC4H,YAAY;MAClC,CAAC,MACI;QACDhO,WAAW,GAAGoG,GAAG,CAAC/G,cAAc,CAAC,CAAC;QAClCW,WAAW,CAACiO,KAAK,CAACjO,WAAW,CAAC6B,CAAC,GAAG,GAAG,EAAE7B,WAAW,CAACgC,CAAC,GAAG,GAAG,EAAEhC,WAAW,CAACuL,KAAK,GAAG,GAAG,EAAEvL,WAAW,CAACsL,MAAM,GAAG,GAAG,CAAC;MAClH;;MAEA;MACA,IAAGtM,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC+H,kBAAkB,CAAC,IAAI,CAACpB,IAAI,EAAEtM,WAAW,EAAE8N,wBAAwB,CAAC,CAAChP,MAAM,KAAK,CAAC,EACvG;;MAEJ;MACA,SAAA6M,EAAA,MAAAuC,qBAAA,GAAmCJ,wBAAwB,EAAAnC,EAAA,GAAAuC,qBAAA,CAAApP,MAAA,EAAA6M,EAAA,IAAE;QAAzD,IAAIwC,uBAAuB,GAAAD,qBAAA,CAAAvC,EAAA;QAC3B,IAAG3M,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEmM,uBAAuB,CAACtM,CAAC,EAAEsM,uBAAuB,CAACnM,CAAC,CAAC,GAAG8K,eAAe,EAAE;UACnIiB,UAAU,GAAG,IAAI;UACjB;QACJ;MACJ;MAEA,IAAG,CAACA,UAAU,EACV;MAEJZ,KAAK,CAACI,gBAAgB,EAAE;MACxBJ,KAAK,CAACvJ,QAAQ,IAAIwC,GAAG,CAAChG,WAAW,CAAC,IAAI,CAAC,CAACtB,MAAM;;MAE9C;MAAA,IAAAgH,UAAA,GAAA/B,0BAAA,CACmBqC,GAAG,CAAChG,WAAW,CAAC,IAAI,CAAC;QAAA2F,MAAA;MAAA;QAAxC,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAA0C;UAAA,IAAlCyC,OAAO,GAAAb,MAAA,CAAArH,KAAA;UACX,IAAIuH,cAAY,GAAG,EAAE;;UAErB;UACA,IAAGrH,OAAO,CAACgP,MAAM,EAAE;YACf,IACI5O,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACxP,OAAO,CAACgP,MAAM,EAAEhH,OAAO,CAACE,SAAS,CAAC,CAAC,CAAC,IAC1D9H,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACxP,OAAO,CAACgP,MAAM,EAAEhH,OAAO,CAAC/D,SAAS,CAAC,CAAC,CAAC,EAClE;cACEoD,cAAY,GAAGrH,OAAO,CAACgP,MAAM;YACjC,CAAC,MACI,IAAG,CAAC5O,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAAC,IAAI,CAACoG,IAAI,EAAE1F,OAAO,EAAEX,cAAY,CAAC,EACxE;UACR;UACA;UAAA,KACK,IAAG,CAACjH,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAAC,IAAI,CAACoG,IAAI,EAAE1F,OAAO,EAAEX,cAAY,CAAC,EAC1E;;UAEF;UACA,IAAI0H,UAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEiE,cAAY,CAACpE,CAAC,EAAEoE,cAAY,CAACjE,CAAC,CAAC;UACzG,IAAG2L,UAAQ,GAAGb,eAAe,EAAE;YAC3BA,eAAe,GAAGa,UAAQ;YAC1BhB,mBAAmB,GAAG1G,cAAY;YAClC4G,aAAa,GAAGzG,GAAG,CAAC9G,MAAM;YAC1BsN,cAAc,GAAGhG,OAAO;UAC5B;QACJ;;QAEA;MAAA,SAAAvC,GAAA;QAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;MAAA;QAAAyB,UAAA,CAAAvB,CAAA;MAAA;MACA,IAAG6B,GAAG,CAAC9F,MAAM,EAAE;QACZ;QACC,IAAG8F,GAAG,CAAC5E,OAAO,CAAC1C,MAAM,GAAG,CAAC,EAAE;UACvB;QACJ;;QAEA;QACA,IAAGF,OAAO,CAACgP,MAAM,EAAE;UACf,IAAInM,MAAM,GAAG2E,GAAG,CAACjG,SAAS,CAAC,IAAI,CAAC;UAChC,IAAIkO,SAAS,GAAG,KAAK;UAAC,IAAA7H,UAAA,GAAAzC,0BAAA,CACLtC,MAAM;YAAAgF,MAAA;UAAA;YAAvB,KAAAD,UAAA,CAAAvC,CAAA,MAAAwC,MAAA,GAAAD,UAAA,CAAAtC,CAAA,IAAAC,IAAA,GAAyB;cAAA,IAAjBC,KAAK,GAAAqC,MAAA,CAAA/H,KAAA;cACT,IAAGM,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACxP,OAAO,CAACgP,MAAM,EAAExJ,KAAK,CAAC,EAAE;gBAChD;gBACA,IAAIuJ,UAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,KAAK,CAACvC,CAAC,EAAEuC,KAAK,CAACpC,CAAC,CAAC;gBAE3F,IAAG2L,UAAQ,GAAGb,eAAe,EAAE;kBAC3BA,eAAe,GAAGa,UAAQ;kBAC1BhB,mBAAmB,GAAGvI,KAAK;kBAC3ByI,aAAa,GAAGzG,GAAG,CAAC9G,MAAM;kBAC1B+O,SAAS,GAAG,IAAI;kBAChB;gBACJ;cACJ;YACJ;UAAC,SAAAhK,GAAA;YAAAmC,UAAA,CAAAlC,CAAA,CAAAD,GAAA;UAAA;YAAAmC,UAAA,CAAAjC,CAAA;UAAA;UAED,IAAG8J,SAAS,EACR;QACR;QAEA,IAAIC,mBAAmB,GAAG,EAAE;QAC5B,IAAI5M,MAAM,GAAG,IAAI1C,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;QACpCF,MAAM,CAACG,CAAC,GAAGuE,GAAG,CAAC9G,MAAM,CAACuC,CAAC,GAAGuE,GAAG,CAAC9G,MAAM,CAACwC,YAAY,IAAIsE,GAAG,CAAC9G,MAAM,CAACyC,OAAO,GAAG,GAAG,CAAC;QAC9EL,MAAM,CAACM,CAAC,GAAGoE,GAAG,CAAC9G,MAAM,CAAC0C,CAAC,GAAGoE,GAAG,CAAC9G,MAAM,CAAC2C,aAAa,IAAImE,GAAG,CAAC9G,MAAM,CAAC4C,OAAO,GAAG,GAAG,CAAC;;QAE/E;QACA,IAAIK,QAAQ,GAAG6D,GAAG,CAAC9G,MAAM,CAACiD,QAAQ;QAClC,IAAGA,QAAQ,KAAK,CAAC,EAAE;UACf,IAAIC,MAAM,GAAG,IAAIxD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACgE,GAAG,CAAC9G,MAAM,CAACuC,CAAC,EAAEuE,GAAG,CAAC9G,MAAM,CAAC0C,CAAC,EAAEN,MAAM,CAACG,CAAC,EAAEH,MAAM,CAACM,CAAC,CAAC;UACjFhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE4D,GAAG,CAAC9G,MAAM,CAACuC,CAAC,EAAEuE,GAAG,CAAC9G,MAAM,CAAC0C,CAAC,EAAEhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAEvD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;UAC3I,IAAII,EAAE,GAAGJ,MAAM,CAACK,SAAS,CAAC,CAAC;UAC3BnB,MAAM,CAACG,CAAC,GAAGe,EAAE,CAACf,CAAC;UACfH,MAAM,CAACM,CAAC,GAAGY,EAAE,CAACZ,CAAC;QACnB;;QAEA;QACA,IAAI1B,MAAM,GAAG,IAAItB,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAACzF,MAAM,CAACG,CAAC,EAAEH,MAAM,CAACM,CAAC,EAAEoE,GAAG,CAAC9G,MAAM,CAAC6D,MAAM,GAAGiD,GAAG,CAAC9G,MAAM,CAAC8D,MAAM,CAAC;QAE9F,IAAGpE,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC4I,eAAe,CAAC,IAAI,CAACjC,IAAI,EAAEhM,MAAM,EAAEgO,mBAAmB,CAAC,EAAE;UAAA,IAAA5H,UAAA,GAAA3C,0BAAA,CACvDuK,mBAAmB;YAAA3H,MAAA;UAAA;YAA3C,KAAAD,UAAA,CAAAzC,CAAA,MAAA0C,MAAA,GAAAD,UAAA,CAAAxC,CAAA,IAAAC,IAAA,GAA6C;cAAA,IAArC8B,aAAY,GAAAU,MAAA,CAAAjI,KAAA;cAChB;cACA,IAAIiP,UAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC6B,IAAI,CAACpD,EAAE,EAAE,IAAI,CAACoD,IAAI,CAACnD,EAAE,EAAElD,aAAY,CAACpE,CAAC,EAAEoE,aAAY,CAACjE,CAAC,CAAC;cAEvG,IAAG2L,UAAQ,GAAGb,eAAe,EAAE;gBAE3BA,eAAe,GAAGa,UAAQ;gBAC1BhB,mBAAmB,GAAG1G,aAAY;gBAClC4G,aAAa,GAAGzG,GAAG,CAAC9G,MAAM;cAC9B;YACJ;UAAC,SAAA+E,GAAA;YAAAqC,UAAA,CAAApC,CAAA,CAAAD,GAAA;UAAA;YAAAqC,UAAA,CAAAnC,CAAA;UAAA;QACL;MACJ;;MAEA;MACA,IAAG6B,GAAG,CAAClG,IAAI,IAAI,WAAW,IAAIkG,GAAG,CAAC3F,QAAQ,CAAC3B,MAAM,GAAG,CAAC,EAAE;QAAA,IAAAsI,UAAA,GAAArD,0BAAA,CACjCqC,GAAG,CAAC3F,QAAQ;UAAA4G,MAAA;QAAA;UAA9B,KAAAD,UAAA,CAAAnD,CAAA,MAAAoD,MAAA,GAAAD,UAAA,CAAAlD,CAAA,IAAAC,IAAA,GAAgC;YAAA,IAAxB7D,OAAM,GAAA+G,MAAA,CAAA3I,KAAA;YACV;YACA,IAAGE,OAAO,CAACgP,MAAM,EAAE;cACf,IAAIS,UAAS,GAAG,KAAK;cAAC,IAAAtC,UAAA,GAAAhI,0BAAA,CAELzD,OAAM,CAACmB,MAAM;gBAAAuK,MAAA;cAAA;gBAA9B,KAAAD,UAAA,CAAA9H,CAAA,MAAA+H,MAAA,GAAAD,UAAA,CAAA7H,CAAA,IAAAC,IAAA,GAAgC;kBAAA,IAAxBC,MAAK,GAAA4H,MAAA,CAAAtN,KAAA;kBACT,IAAGM,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACxP,OAAO,CAACgP,MAAM,EAAExJ,MAAK,CAAC,EAAE;oBAChD;oBACA,IAAIuJ,UAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,MAAK,CAACvC,CAAC,EAAEuC,MAAK,CAACpC,CAAC,CAAC;oBAE3F,IAAG2L,UAAQ,GAAGb,eAAe,EAAE;sBAC3BA,eAAe,GAAGa,UAAQ;sBAC1BhB,mBAAmB,GAAGvI,MAAK;sBAC3ByI,aAAa,GAAGzG,GAAG,CAAC9G,MAAM;sBAC1B+O,UAAS,GAAG,IAAI;sBAChB;oBACJ;kBACJ;gBACJ;cAAC,SAAAhK,GAAA;gBAAA0H,UAAA,CAAAzH,CAAA,CAAAD,GAAA;cAAA;gBAAA0H,UAAA,CAAAxH,CAAA;cAAA;cAED,IAAG8J,UAAS,EACR;YACR;YAEA,IAAIC,oBAAmB,GAAG,EAAE;YAE5B,IAAGtP,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC4I,eAAe,CAAC,IAAI,CAACjC,IAAI,EAAEhM,OAAM,EAAEgO,oBAAmB,CAAC,EAAE;cAAA,IAAAE,UAAA,GAAAzK,0BAAA,CACvDuK,oBAAmB;gBAAAG,MAAA;cAAA;gBAA3C,KAAAD,UAAA,CAAAvK,CAAA,MAAAwK,MAAA,GAAAD,UAAA,CAAAtK,CAAA,IAAAC,IAAA,GAA6C;kBAAA,IAArC8B,cAAY,GAAAwI,MAAA,CAAA/P,KAAA;kBAChB;kBACA,IAAIiP,UAAQ,GAAG3O,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC6B,IAAI,CAACpD,EAAE,EAAE,IAAI,CAACoD,IAAI,CAACnD,EAAE,EAAElD,cAAY,CAACpE,CAAC,EAAEoE,cAAY,CAACjE,CAAC,CAAC;kBAEvG,IAAG2L,UAAQ,GAAGb,eAAe,EAAE;oBAC3BA,eAAe,GAAGa,UAAQ;oBAC1BhB,mBAAmB,GAAG1G,cAAY;oBAClC4G,aAAa,GAAGzG,GAAG,CAAC9G,MAAM;kBAC9B;gBACJ;cAAC,SAAA+E,GAAA;gBAAAmK,UAAA,CAAAlK,CAAA,CAAAD,GAAA;cAAA;gBAAAmK,UAAA,CAAAjK,CAAA;cAAA;YACL;UACJ;QAAC,SAAAF,GAAA;UAAA+C,UAAA,CAAA9C,CAAA,CAAAD,GAAA;QAAA;UAAA+C,UAAA,CAAA7C,CAAA;QAAA;MACL;IACJ;;IAEA;EAAA,SAAAF,GAAA;IAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;EAAA;IAAAG,UAAA,CAAAD,CAAA;EAAA;EACA,IAAGwI,QAAQ,EAAE;IACT,IAAI,CAACnF,MAAM,CAACyF,IAAI,EAAE;IAClB,IAAI,CAACzF,MAAM,CAAC0F,mBAAmB,IAAIH,KAAK,CAACG,mBAAmB;IAC5D,IAAI,CAAC1F,MAAM,CAAC2F,gBAAgB,IAAIJ,KAAK,CAACI,gBAAgB;IACtD,IAAI,CAAC3F,MAAM,CAAChE,QAAQ,IAAIuJ,KAAK,CAACvJ,QAAQ;EAC1C,CAAC,MACI;IACDuJ,KAAK,CAACK,IAAI,GAAGP,WAAW,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS;IAC1C,IAAI,CAACpF,MAAM,GAAGuF,KAAK;EACvB;EAEA,IAAIuB,MAAM;EACV,IAAG,CAAC/B,mBAAmB,EAAE;IACrB,IAAG,IAAI,CAACgC,wBAAwB,EAC5B,OAAO,KAAK;IAEhBD,MAAM,GAAG,IAAI,CAACpC,IAAI,CAACzJ,SAAS,CAAC,CAAC;EAClC,CAAC,MACI;IACD6L,MAAM,GAAG,IAAI1P,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC+K,mBAAmB,CAAC9K,CAAC,EAAE8K,mBAAmB,CAAC3K,CAAC,CAAC;IAC5E0M,MAAM,CAAC9H,OAAO,GAAGgG,cAAc;IAC/B8B,MAAM,CAACpP,MAAM,GAAGuN,aAAa;EACjC;EAEA,IAAG,IAAI,CAAC+B,KAAK,EAAE;IACXF,MAAM,CAAC7M,CAAC,GAAGmB,IAAI,CAAC4L,KAAK,CAACF,MAAM,CAAC7M,CAAC,CAAC;IAC/B6M,MAAM,CAAC1M,CAAC,GAAGgB,IAAI,CAAC4L,KAAK,CAACF,MAAM,CAAC1M,CAAC,CAAC;EACnC;EAEA,IAAG,CAAC+K,QAAQ,EACR,IAAI,CAAC8B,SAAS,CAAC,CAACH,MAAM,CAAC,CAAC;EAE5B,OAAOA,MAAM;AACjB;;;;;;;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,UAAUA,CAAA,EAAe;EAAA,IAAdlQ,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACnC,IAAIkQ,aAAa,GAAG,IAAI,CAAC1L,KAAK;EAC9B,IAAIoK,aAAa,GAAG,EAAE;EACtB,IAAIuB,IAAI,GAAG,EAAE;EACb,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAIC,aAAa,GAAG,EAAE;EACtB,IAAIlC,SAAS,GAAGC,WAAW,CAACC,GAAG,CAAC,CAAC;EACjC;EACA,IAAI,CAACtF,MAAM,GAAG;IACVwF,MAAM,EAAE,YAAY;IACpBC,IAAI,EAAE,CAAC;IACPC,mBAAmB,EAAE,CAAC;IACtBC,gBAAgB,EAAE,CAAC;IACnB3J,QAAQ,EAAE,CAAC;IACX4J,IAAI,EAAE;EACV,CAAC;;EAED;EACA,IAAG,CAAC5O,OAAO,CAACiP,OAAO,EAAE;IACjB,IAAG,IAAI,CAAChJ,UAAU,EACdjG,OAAO,CAACiP,OAAO,GAAG,IAAI,CAAChJ,UAAU,CAACgD,aAAa,CAAC,KAEhD,OAAO4F,aAAa;EAC5B;;EAEA;EACA,IAAG,IAAI,CAAC5I,UAAU,IAAI,IAAI,CAACA,UAAU,CAAC7E,WAAW,EAAE;IAAA,IAAA8D,SAAA,GAAAC,0BAAA,CAC9B,IAAI,CAACc,UAAU,CAAC7E,WAAW,CAACyB,MAAM;MAAAuC,KAAA;IAAA;MAAnD,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAqD;QAAA,IAA7CC,KAAK,GAAAJ,KAAA,CAAAtF,KAAA;QACTuQ,UAAU,CAACzL,IAAI,CAAC;UACZY,KAAK,EAAEA,KAAK;UACZf,KAAK,EAAErE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,KAAK,CAACvC,CAAC,EAAEuC,KAAK,CAACpC,CAAC;QACnF,CAAC,CAAC;MACN;IAAC,SAAAqC,GAAA;MAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;IAAA;MAAAP,SAAA,CAAAS,CAAA;IAAA;EACL;EAEA,KAAI,IAAIG,CAAC,GAAC,CAAC,EAAEQ,OAAO,GAAGtG,OAAO,CAACiP,OAAO,CAAC/O,MAAM,EAAE4F,CAAC,GAAGQ,OAAO,EAAER,CAAC,EAAE,EAAE;IAC7D,IAAIpF,MAAM,GAAGV,OAAO,CAACiP,OAAO,CAACnJ,CAAC,CAAC;IAC/B;IACA,IAAG,CAAC,IAAI,CAACyK,aAAa,CAAC7P,MAAM,CAAC,EAC1B;IAEJ4P,aAAa,CAAC1L,IAAI,CAAClE,MAAM,CAAC;IAE1B,IAAI8G,GAAG;MAAEpG,WAAW;IACpB,IAAGV,MAAM,CAACY,IAAI,KAAK,MAAM,IAAIZ,MAAM,CAACY,IAAI,KAAK,WAAW,EACpDkG,GAAG,GAAG9G,MAAM,CAAC8B,YAAY,CAAC,KAE1BgF,GAAG,GAAG9G,MAAM,CAAC+B,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;;IAEzC;IACAtF,WAAW,GAAGoG,GAAG,CAAC/G,cAAc,CAAC,CAAC;IAClCW,WAAW,CAACiO,KAAK,CAACjO,WAAW,CAAC6B,CAAC,GAAG,GAAG,EAAE7B,WAAW,CAACgC,CAAC,GAAG,GAAG,EAAEhC,WAAW,CAACuL,KAAK,GAAG,GAAG,EAAEvL,WAAW,CAACsL,MAAM,GAAG,GAAG,CAAC;IAE9GlF,GAAG,CAAC4H,YAAY,GAAGhO,WAAW;IAE9BgP,IAAI,CAACxL,IAAI,CAAC4C,GAAG,CAAC;IACd;IAAA,IAAA5B,UAAA,GAAAT,0BAAA,CACiBqC,GAAG,CAACjG,SAAS,CAAC,IAAI,CAAC;MAAAsE,MAAA;IAAA;MAApC,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAAsC;QAAA,IAA9BC,MAAK,GAAAK,MAAA,CAAA/F,KAAA;QACTuQ,UAAU,CAACzL,IAAI,CAAC;UACZY,KAAK,EAAEA,MAAK;UACZf,KAAK,EAAErE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,MAAK,CAACvC,CAAC,EAAEuC,MAAK,CAACpC,CAAC;QACnF,CAAC,CAAC;MACN;;MAEA;IAAA,SAAAqC,GAAA;MAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;IAAA;MAAAG,UAAA,CAAAD,CAAA;IAAA;IACA,KAAI,IAAIgB,CAAC,GAAGb,CAAC,GAAC,CAAC,EAAEc,OAAO,GAAG5G,OAAO,CAACiP,OAAO,CAAC/O,MAAM,EAAEyG,CAAC,GAAGC,OAAO,EAAED,CAAC,EAAE,EAAC;MAChE,IAAI6J,OAAO,GAAGxQ,OAAO,CAACiP,OAAO,CAACtI,CAAC,CAAC;MAChC,IAAIG,IAAI;MACR,IAAG0J,OAAO,CAAClP,IAAI,KAAK,MAAM,IAAIkP,OAAO,CAAClP,IAAI,KAAK,WAAW,EACtDwF,IAAI,GAAG0J,OAAO,CAAChO,YAAY,CAAC,KAC3B;QACDsE,IAAI,GAAG0J,OAAO,CAAC/N,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;MAC3C;MACA;MACA,IAAG,CAACtG,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACC,oBAAoB,CAACQ,GAAG,CAAC/G,cAAc,CAAC,CAAC,EAAEqG,IAAI,CAACrG,cAAc,CAAC,CAAC,CAAC,EACxF;;MAEJ;MAAA,IAAAyG,UAAA,GAAA/B,0BAAA,CACoBqC,GAAG,CAAChG,WAAW,CAAC,IAAI,CAAC;QAAA2F,MAAA;MAAA;QAAzC,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAA2C;UAAA,IAAnC0B,QAAQ,GAAAE,MAAA,CAAArH,KAAA;UAAA,IAAA8H,UAAA,GAAAzC,0BAAA,CACQ2B,IAAI,CAACtF,WAAW,CAAC,IAAI,CAAC;YAAAqG,MAAA;UAAA;YAA1C,KAAAD,UAAA,CAAAvC,CAAA,MAAAwC,MAAA,GAAAD,UAAA,CAAAtC,CAAA,IAAAC,IAAA,GAA4C;cAAA,IAApC6B,QAAQ,GAAAS,MAAA,CAAA/H,KAAA;cACZ,IAAIuH,YAAY,GAAG,EAAE;cACrB,IAAG,CAACjH,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAACL,QAAQ,EAAEG,QAAQ,EAAEC,YAAY,CAAC,EACnE;cAEJ,IAAI2H,MAAM,GAAG;gBACTxJ,KAAK,EAAE,IAAIpF,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACqE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,CAAC;gBAC5DqB,KAAK,EAAErE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEiE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC;cACjG,CAAC;cACD4L,MAAM,CAACxJ,KAAK,CAAC6B,YAAY,GAAG,KAAK;cACjCgJ,UAAU,CAACzL,IAAI,CAACoK,MAAM,CAAC;YAC3B;UAAC,SAAAvJ,GAAA;YAAAmC,UAAA,CAAAlC,CAAA,CAAAD,GAAA;UAAA;YAAAmC,UAAA,CAAAjC,CAAA;UAAA;QACL;MAAC,SAAAF,GAAA;QAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;MAAA;QAAAyB,UAAA,CAAAvB,CAAA;MAAA;IACL;EACJ;;EAEA;EACA0K,UAAU,CAACI,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAC;IAC1B;IACA,IAAGD,CAAC,CAACjM,KAAK,IAAIkM,CAAC,CAAClM,KAAK,EAAE;MACnB,IAAGrE,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEsN,CAAC,CAAClL,KAAK,CAACvC,CAAC,EAAEyN,CAAC,CAAClL,KAAK,CAACpC,CAAC,CAAC,GAAGhD,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEuN,CAAC,CAACnL,KAAK,CAACvC,CAAC,EAAE0N,CAAC,CAACnL,KAAK,CAACpC,CAAC,CAAC,EAClK,OAAO,CAAC,CAAC,KAET,OAAO,CAAC,CAAC;IACjB;IAEA,OAAOsN,CAAC,CAACjM,KAAK,GAAGkM,CAAC,CAAClM,KAAK;EAC5B,CAAC,CAAC4B,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,IAAIuK,cAAc,GAAG;IACjBnM,KAAK,EAAE;EACX,CAAC;;EAED;EACA,SAAAsI,EAAA,MAAA8D,WAAA,GAAkBR,UAAU,EAAAtD,EAAA,GAAA8D,WAAA,CAAA3Q,MAAA,EAAA6M,EAAA,IAAC;IAAzB,IAAIiC,OAAM,GAAA6B,WAAA,CAAA9D,EAAA;IACV;IACA,IAAGiC,OAAM,CAACvK,KAAK,KAAKmM,cAAc,CAACnM,KAAK,EAAE;MACtC;IACJ;IAEAmM,cAAc,GAAG5B,OAAM;IAEvB,IAAI,CAACxB,QAAQ,CAACwB,OAAM,CAACvK,KAAK,CAAC;IAC3B,IAAI4C,aAAY,GAAG,IAAI,CAACyG,IAAI,CAAC;MACzBmB,OAAO,EAAEqB,aAAa;MACtBtB,MAAM,EAAEA,OAAM,CAACxJ,KAAK;MACpB2I,QAAQ,EAAE;IACd,CAAC,CAAC;IAEF,IAAG9G,aAAY,EAAC;MACZ;MACA,IAAIyJ,SAAS,GAAG,KAAK;MACrB,IAAG,IAAI,CAACd,KAAK,EAAE;QACX,IAAIe,aAAa,GAAG,IAAI3Q,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACoB,IAAI,CAAC4L,KAAK,CAAChB,OAAM,CAACxJ,KAAK,CAACvC,CAAC,CAAC,EAAEmB,IAAI,CAAC4L,KAAK,CAAChB,OAAM,CAACxJ,KAAK,CAACpC,CAAC,CAAC,CAAC;QACjG0N,SAAS,GAAG1Q,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACuB,aAAa,EAAE1J,aAAY,CAAC;MACrE,CAAC,MACI;QACDyJ,SAAS,GAAG1Q,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACR,OAAM,CAACxJ,KAAK,EAAE6B,aAAY,CAAC;MACpE;;MAEA;MACA,IAAGyJ,SAAS,EAAE;QACV,IAAG9B,OAAM,CAACxJ,KAAK,CAAC6B,YAAY,KAAK,KAAK,EAClCyJ,SAAS,GAAG,KAAK,CAAC,KACjB,IAAG9B,OAAM,CAACxJ,KAAK,CAAC6B,YAAY,IAAIjH,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAAC,IAAI,CAACoG,IAAI,EAAEsB,OAAM,CAACxJ,KAAK,CAAC6B,YAAY,CAAC,EACxGyJ,SAAS,GAAG,KAAK;MACzB;MAEA,IAAGA,SAAS,EAAE;QACV,IAAI,CAACtD,QAAQ,CAACwB,OAAM,CAACvK,KAAK,GAAG,MAAM,CAAC;QACpC,IAAIuM,aAAa,GAAG,IAAI,CAAClD,IAAI,CAAC;UAC1BmB,OAAO,EAAEqB,aAAa;UACtBnC,QAAQ,EAAE;QACd,CAAC,CAAC;QAEF,IAAG6C,aAAa,EAAE;UACdnC,aAAa,CAACjK,IAAI,CAACoM,aAAa,CAAC;QACrC;QAEAnC,aAAa,CAACjK,IAAI,CAACyC,aAAY,CAAC;QAEhC,IAAI,CAACmG,QAAQ,CAACwB,OAAM,CAACvK,KAAK,GAAG,MAAM,CAAC;QACpC,IAAIwM,aAAa,GAAG,IAAI,CAACnD,IAAI,CAAC;UAC1BmB,OAAO,EAAEqB,aAAa;UACtBnC,QAAQ,EAAE;QACd,CAAC,CAAC;QAEF,IAAG8C,aAAa,EAAE;UACdpC,aAAa,CAACjK,IAAI,CAACqM,aAAa,CAAC;QACrC;QAEA;MACJ;MAEApC,aAAa,CAACjK,IAAI,CAACyC,aAAY,CAAC;IACpC;EACJ;EAEA,IAAI,CAACmG,QAAQ,CAAC2C,aAAa,CAAC;EAC5B,IAAI,CAACtB,aAAa,GAAGA,aAAa;EAElC,IAAG,IAAI,CAACqC,SAAS,EACb,IAAI,CAACC,mBAAmB,GAAG,IAAI,CAAC3F,KAAK,CAAC,CAAC;EAE3C,IAAI,CAACxC,MAAM,CAAC4F,IAAI,GAAGP,WAAW,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS;EAEhD,IAAI,CAAC6B,SAAS,CAACpB,aAAa,CAAC;EAE7B,OAAOA,aAAa;AACxB;;;;;;;;;;;;;;;;;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASuC,QAAQA,CAAA,EAAe;EAAA,IAAdpR,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACjC,IAAIkQ,aAAa,GAAG,IAAI,CAAC1L,KAAK;EAC9B,IAAIoK,aAAa,GAAG,EAAE;EACtB,IAAIuB,IAAI,GAAG,EAAE;EACb,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAIC,aAAa,GAAG,EAAE;EACtB,IAAIe,IAAI,GAAG,IAAI,CAACA,IAAI;EACpB,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIpD,SAAS,GAAGC,WAAW,CAACC,GAAG,CAAC,CAAC;EACjC;EACA,IAAI,CAACtF,MAAM,GAAG;IACVwF,MAAM,EAAE,UAAU;IAClBC,IAAI,EAAE,CAAC;IACPC,mBAAmB,EAAE,CAAC;IACtBC,gBAAgB,EAAE,CAAC;IACnB3J,QAAQ,EAAE,CAAC;IACX4J,IAAI,EAAE;EACV,CAAC;;EAED;EACA,IAAG5O,OAAO,CAACqR,IAAI,KAAKlR,SAAS,EACzBkR,IAAI,GAAGrR,OAAO,CAACqR,IAAI;EACvB,IAAGrR,OAAO,CAACyR,OAAO,KAAKtR,SAAS,EAC5BkR,IAAI,GAAGjR,MAAM,CAACgE,IAAI,CAACyJ,QAAQ,CAAC7N,OAAO,CAACyR,OAAO,CAAC;;EAEhD;EACAH,QAAQ,GAAG,IAAI,CAAC7M,KAAK,GAAG4M,IAAI,GAAG,CAAC;EAChCE,QAAQ,GAAG,IAAI,CAAC9M,KAAK,GAAG4M,IAAI,GAAG,CAAC;;EAEhC;EACA,IAAI,CAAC7D,QAAQ,CAAC8D,QAAQ,CAAC;EACvBjB,UAAU,CAACzL,IAAI,CAAC;IACZY,KAAK,EAAE,IAAI,CAACkI,IAAI,CAACzJ,SAAS,CAAC,CAAC;IAC5BQ,KAAK,EAAE6M,QAAQ;IACfI,cAAc,EAAEtR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAAC,CAACN,IAAI,GAAG,CAAC;EAClD,CAAC,CAAC;EAEF,IAAI,CAAC7D,QAAQ,CAAC+D,QAAQ,CAAC;EACvBlB,UAAU,CAACzL,IAAI,CAAC;IACZY,KAAK,EAAE,IAAI,CAACkI,IAAI,CAACzJ,SAAS,CAAC,CAAC;IAC5BQ,KAAK,EAAE8M,QAAQ;IACfG,cAAc,EAAEtR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACN,IAAI,GAAG,CAAC;EACjD,CAAC,CAAC;;EAEF;EACA,IAAG,CAACrR,OAAO,CAACiP,OAAO,EAAE;IACjB,IAAG,IAAI,CAAChJ,UAAU,EACdjG,OAAO,CAACiP,OAAO,GAAG,IAAI,CAAChJ,UAAU,CAACgD,aAAa,CAAC,KAEhD,OAAO4F,aAAa;EAC5B;;EAEA;EACA,IAAG,IAAI,CAAC5I,UAAU,IAAI,IAAI,CAACA,UAAU,CAAC7E,WAAW,EAAE;IAAA,IAAA8D,SAAA,GAAAC,0BAAA,CAC9B,IAAI,CAACc,UAAU,CAAC7E,WAAW,CAACyB,MAAM;MAAAuC,KAAA;IAAA;MAAnD,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAqD;QAAA,IAA7CC,KAAK,GAAAJ,KAAA,CAAAtF,KAAA;QAET,IAAI2E,KAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,KAAK,CAACvC,CAAC,EAAEuC,KAAK,CAACpC,CAAC,CAAC;QACrF,IAAIsO,cAAc,GAAGtR,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC8N,eAAe,CAACxR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAAClN,KAAK,CAAC,EAAErE,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACxB,aAAa,CAAC,CAAC;QAExH,IAAG/L,IAAI,CAACyN,GAAG,CAACH,cAAc,CAAC,GAAGtR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,EAAE;UAC1DhB,UAAU,CAACzL,IAAI,CAAC;YACZY,KAAK,EAAEA,KAAK;YACZf,KAAK,EAAEA,KAAK;YACZiN,cAAc,EAAE,CAACA;UACrB,CAAC,CAAC;QACN;MACJ;IAAC,SAAAjM,GAAA;MAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;IAAA;MAAAP,SAAA,CAAAS,CAAA;IAAA;EACL;EAEA,KAAI,IAAIG,CAAC,GAAC,CAAC,EAAEQ,OAAO,GAAGtG,OAAO,CAACiP,OAAO,CAAC/O,MAAM,EAAE4F,CAAC,GAAGQ,OAAO,EAAER,CAAC,EAAE,EAAE;IAC7D,IAAIpF,MAAM,GAAGV,OAAO,CAACiP,OAAO,CAACnJ,CAAC,CAAC;IAC/B;IACA,IAAG,CAAC,IAAI,CAACyK,aAAa,CAAC7P,MAAM,CAAC,EAC1B;IAEJ4P,aAAa,CAAC1L,IAAI,CAAClE,MAAM,CAAC;IAE1B,IAAI8G,GAAG;MAAEpG,WAAW;IACpB,IAAGV,MAAM,CAACY,IAAI,KAAK,MAAM,IAAIZ,MAAM,CAACY,IAAI,KAAK,WAAW,EACpDkG,GAAG,GAAG9G,MAAM,CAAC8B,YAAY,CAAC,KAE1BgF,GAAG,GAAG9G,MAAM,CAAC+B,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;;IAEzC;IACAtF,WAAW,GAAGoG,GAAG,CAAC/G,cAAc,CAAC,CAAC;IAClCW,WAAW,CAACiO,KAAK,CAACjO,WAAW,CAAC6B,CAAC,GAAG,GAAG,EAAE7B,WAAW,CAACgC,CAAC,GAAG,GAAG,EAAEhC,WAAW,CAACuL,KAAK,GAAG,GAAG,EAAEvL,WAAW,CAACsL,MAAM,GAAG,GAAG,CAAC;IAE9GlF,GAAG,CAAC4H,YAAY,GAAGhO,WAAW;IAE9BgP,IAAI,CAACxL,IAAI,CAAC4C,GAAG,CAAC;IACd;IAAA,IAAA5B,UAAA,GAAAT,0BAAA,CACiBqC,GAAG,CAACjG,SAAS,CAAC,IAAI,CAAC;MAAAsE,MAAA;IAAA;MAApC,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAAsC;QAAA,IAA9BC,MAAK,GAAAK,MAAA,CAAA/F,KAAA;QAET,IAAI2E,OAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,MAAK,CAACvC,CAAC,EAAEuC,MAAK,CAACpC,CAAC,CAAC;QACrF,IAAIsO,gBAAc,GAAGtR,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC8N,eAAe,CAACxR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAAClN,OAAK,CAAC,EAAErE,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACxB,aAAa,CAAC,CAAC;QAExH,IAAG/L,IAAI,CAACyN,GAAG,CAACH,gBAAc,CAAC,GAAGtR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,EAAE;UAC1DhB,UAAU,CAACzL,IAAI,CAAC;YACZY,KAAK,EAAEA,MAAK;YACZf,KAAK,EAAErE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEoC,MAAK,CAACvC,CAAC,EAAEuC,MAAK,CAACpC,CAAC,CAAC;YAChFsO,cAAc,EAAE,CAACA;UACrB,CAAC,CAAC;QACN;MACJ;;MAEA;IAAA,SAAAjM,GAAA;MAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;IAAA;MAAAG,UAAA,CAAAD,CAAA;IAAA;IACA,KAAI,IAAIgB,CAAC,GAAGb,CAAC,GAAC,CAAC,EAAEc,OAAO,GAAG5G,OAAO,CAACiP,OAAO,CAAC/O,MAAM,EAAEyG,CAAC,GAAGC,OAAO,EAAED,CAAC,EAAE,EAAC;MAChE,IAAI6J,OAAO,GAAGxQ,OAAO,CAACiP,OAAO,CAACtI,CAAC,CAAC;MAChC,IAAIG,IAAI;MACR,IAAG0J,OAAO,CAAClP,IAAI,KAAK,MAAM,IAAIkP,OAAO,CAAClP,IAAI,KAAK,WAAW,EACtDwF,IAAI,GAAG0J,OAAO,CAAChO,YAAY,CAAC,KAE5BsE,IAAI,GAAG0J,OAAO,CAAC/N,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC;MAC3C;MACA,IAAG,CAACtG,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACC,oBAAoB,CAACQ,GAAG,CAAC/G,cAAc,CAAC,CAAC,EAAEqG,IAAI,CAACrG,cAAc,CAAC,CAAC,CAAC,EACxF;;MAEJ;MAAA,IAAAyG,UAAA,GAAA/B,0BAAA,CACoBqC,GAAG,CAAChG,WAAW,CAAC,IAAI,CAAC;QAAA2F,MAAA;MAAA;QAAzC,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAA2C;UAAA,IAAnC0B,QAAQ,GAAAE,MAAA,CAAArH,KAAA;UAAA,IAAA8H,UAAA,GAAAzC,0BAAA,CACQ2B,IAAI,CAACtF,WAAW,CAAC,IAAI,CAAC;YAAAqG,MAAA;UAAA;YAA1C,KAAAD,UAAA,CAAAvC,CAAA,MAAAwC,MAAA,GAAAD,UAAA,CAAAtC,CAAA,IAAAC,IAAA,GAA4C;cAAA,IAApC6B,QAAQ,GAAAS,MAAA,CAAA/H,KAAA;cACZ,IAAIuH,YAAY,GAAG,EAAE;cACrB,IAAG,CAACjH,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACO,UAAU,CAACL,QAAQ,EAAEG,QAAQ,EAAEC,YAAY,CAAC,EACnE;cACJ,IAAI5C,MAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEiE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,CAAC;cACnG,IAAIsO,eAAc,GAAGtR,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC8N,eAAe,CAACxR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAAClN,MAAK,CAAC,EAAErE,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACxB,aAAa,CAAC,CAAC;cAExH,IAAG/L,IAAI,CAACyN,GAAG,CAACH,eAAc,CAAC,GAAGtR,MAAM,CAACgE,IAAI,CAACuN,QAAQ,CAACN,IAAI,GAAG,CAAC,CAAC,EAAE;gBAC1DhB,UAAU,CAACzL,IAAI,CAAC;kBACZY,KAAK,EAAE,IAAIpF,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACqE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,CAAC;kBAC5DqB,KAAK,EAAErE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC+H,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEiE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,CAAC;kBAC9FsO,cAAc,EAAE,CAACA;gBACrB,CAAC,CAAC;cACN;YACJ;UAAC,SAAAjM,GAAA;YAAAmC,UAAA,CAAAlC,CAAA,CAAAD,GAAA;UAAA;YAAAmC,UAAA,CAAAjC,CAAA;UAAA;QACL;MAAC,SAAAF,GAAA;QAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;MAAA;QAAAyB,UAAA,CAAAvB,CAAA;MAAA;IACL;EACJ;;EAEA;EACA0K,UAAU,CAACI,IAAI,CAAC,UAASC,CAAC,EAAEC,CAAC,EAAC;IAC1B;IACA,IAAGD,CAAC,CAACjM,KAAK,IAAIkM,CAAC,CAAClM,KAAK,EAAE;MACnB,IAAGrE,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEsN,CAAC,CAAClL,KAAK,CAACvC,CAAC,EAAEyN,CAAC,CAAClL,KAAK,CAACpC,CAAC,CAAC,GAAGhD,MAAM,CAACgE,IAAI,CAACwH,QAAQ,CAACC,OAAO,CAAC,IAAI,CAAC3H,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAEuN,CAAC,CAACnL,KAAK,CAACvC,CAAC,EAAE0N,CAAC,CAACnL,KAAK,CAACpC,CAAC,CAAC,EAClK,OAAO,CAAC,CAAC,KAET,OAAO,CAAC,CAAC;IACjB;IAEA,OAAOsN,CAAC,CAACgB,cAAc,GAAGf,CAAC,CAACe,cAAc;EAC9C,CAAC,CAACrL,IAAI,CAAC,IAAI,CAAC,CAAC;EAEb,IAAIuK,cAAc,GAAG;IACjBnM,KAAK,EAAE;EACX,CAAC;;EAED;EACA,SAAAsI,EAAA,MAAA8D,WAAA,GAAkBR,UAAU,EAAAtD,EAAA,GAAA8D,WAAA,CAAA3Q,MAAA,EAAA6M,EAAA,IAAC;IAAzB,IAAIiC,MAAM,GAAA6B,WAAA,CAAA9D,EAAA;IACV;IACA,IAAGiC,MAAM,CAACvK,KAAK,KAAKmM,cAAc,CAACnM,KAAK,EAAE;MACtC;IACJ;IAEAmM,cAAc,GAAG5B,MAAM;IAEvB,IAAI,CAACxB,QAAQ,CAACwB,MAAM,CAACvK,KAAK,CAAC;IAC3B,IAAI4C,aAAY,GAAG,IAAI,CAACyG,IAAI,CAAC;MACzBmB,OAAO,EAAEqB,aAAa;MACtBtB,MAAM,EAAEA,MAAM,CAACxJ,KAAK;MACpB2I,QAAQ,EAAE;IACd,CAAC,CAAC;IACF,IAAG9G,aAAY,EAAC;MACZ;MACA,IAAIyJ,SAAS,GAAG,KAAK;MACrB,IAAG,IAAI,CAACd,KAAK,EAAE;QACX,IAAIe,aAAa,GAAG,IAAI3Q,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACoB,IAAI,CAAC4L,KAAK,CAAChB,MAAM,CAACxJ,KAAK,CAACvC,CAAC,CAAC,EAAEmB,IAAI,CAAC4L,KAAK,CAAChB,MAAM,CAACxJ,KAAK,CAACpC,CAAC,CAAC,CAAC;QACjG0N,SAAS,GAAG1Q,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACuB,aAAa,EAAE1J,aAAY,CAAC;MACrE,CAAC,MACI;QACDyJ,SAAS,GAAG1Q,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAACwM,MAAM,CAACR,MAAM,CAACxJ,KAAK,EAAE6B,aAAY,CAAC;MACpE;MACA,IAAGyJ,SAAS,EAAE;QACV,IAAI,CAACtD,QAAQ,CAACwB,MAAM,CAACvK,KAAK,GAAG,MAAM,CAAC;QACpC,IAAIuM,aAAa,GAAG,IAAI,CAAClD,IAAI,CAAC;UAC1BmB,OAAO,EAAEqB,aAAa;UACtBnC,QAAQ,EAAE;QACd,CAAC,CAAC;QAEF,IAAG6C,aAAa,EAAE;UACdnC,aAAa,CAACjK,IAAI,CAACoM,aAAa,CAAC;QACrC;QAEAnC,aAAa,CAACjK,IAAI,CAACyC,aAAY,CAAC;QAEhC,IAAI,CAACmG,QAAQ,CAACwB,MAAM,CAACvK,KAAK,GAAG,MAAM,CAAC;QACpC,IAAIwM,aAAa,GAAG,IAAI,CAACnD,IAAI,CAAC;UAC1BmB,OAAO,EAAEqB,aAAa;UACtBnC,QAAQ,EAAE;QACd,CAAC,CAAC;QAEF,IAAG8C,aAAa,EAAE;UACdpC,aAAa,CAACjK,IAAI,CAACqM,aAAa,CAAC;QACrC;QAEA;MACJ;MAEApC,aAAa,CAACjK,IAAI,CAACyC,aAAY,CAAC;IACpC;EACJ;EAEA,IAAI,CAACmG,QAAQ,CAAC2C,aAAa,CAAC;EAC5B,IAAI,CAACtB,aAAa,GAAGA,aAAa;EAClC,IAAG,IAAI,CAACqC,SAAS,EACb,IAAI,CAACC,mBAAmB,GAAG,IAAI,CAAC3F,KAAK,CAACqD,aAAa,EAAE,KAAK,CAAC;EAE/D,IAAI,CAAC7F,MAAM,CAAC4F,IAAI,GAAGP,WAAW,CAACC,GAAG,CAAC,CAAC,GAAGF,SAAS;EAEhD,IAAI,CAAC6B,SAAS,CAACpB,aAAa,CAAC;EAE7B,OAAOA,aAAa;AACxB;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASiD,OAAOA,CAAA,EAAW;EAAA,IAAVT,IAAI,GAAApR,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC5B,IAAI,CAACoR,IAAI,GAAGA,IAAI;EAChB,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASU,UAAUA,CAAA,EAAW;EAAA,IAAVV,IAAI,GAAApR,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAC/B,IAAI,CAACoR,IAAI,GAAGjR,MAAM,CAACgE,IAAI,CAACyJ,QAAQ,CAACwD,IAAI,CAAC;EACtC,OAAO,IAAI;AACf;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAShQ,MAAMA,CAACrB,OAAO,EAAE;EAC5B,IAAI,CAACU,MAAM,GAAGV,OAAO,CAACU,MAAM;EAC5B;EACA,IAAGV,OAAO,CAACkE,MAAM,KAAK/D,SAAS,EAC3B,IAAI,CAAC+D,MAAM,CAACmL,KAAK,CAACrP,OAAO,CAACkE,MAAM,CAACjB,CAAC,EAAEjD,OAAO,CAACkE,MAAM,CAACd,CAAC,CAAC;;EAEzD;EACA,IAAGpD,OAAO,CAACyE,KAAK,KAAKtE,SAAS,EAC1B,IAAI,CAACsE,KAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC2J,SAAS,CAACzN,OAAO,CAACyE,KAAK,CAAC;;EAE3D;EACA,IAAGzE,OAAO,CAACgS,QAAQ,KAAK7R,SAAS,EAC7B,IAAI,CAACsE,KAAK,GAAGrE,MAAM,CAACgE,IAAI,CAACN,KAAK,CAAC2J,SAAS,CAACrN,MAAM,CAACgE,IAAI,CAACyJ,QAAQ,CAAC7N,OAAO,CAACgS,QAAQ,CAAC,CAAC;;EAEpF;EACA,IAAGhS,OAAO,CAACqR,IAAI,KAAKlR,SAAS,EACzB,IAAI,CAACkR,IAAI,GAAGrR,OAAO,CAACqR,IAAI;;EAE5B;EACA,IAAGrR,OAAO,CAACyR,OAAO,KAAKtR,SAAS,EAC5B,IAAI,CAACkR,IAAI,GAAGjR,MAAM,CAACgE,IAAI,CAACyJ,QAAQ,CAAC7N,OAAO,CAACyR,OAAO,CAAC;;EAErD;EACA,IAAGzR,OAAO,CAAC2N,QAAQ,KAAKxN,SAAS,EAC7B,IAAI,CAACwN,QAAQ,GAAG3N,OAAO,CAAC2N,QAAQ;;EAEpC;EACA,IAAG3N,OAAO,CAACiS,cAAc,KAAK9R,SAAS,EACnC,IAAI,CAAC8R,cAAc,GAAGjS,OAAO,CAACiS,cAAc;;EAEhD;EACA,IAAGjS,OAAO,CAAC0L,cAAc,KAAKvL,SAAS,EACnC,IAAI,CAACuL,cAAc,GAAG1L,OAAO,CAAC0L,cAAc;;EAEhD;EACA,IAAG1L,OAAO,CAAC+P,wBAAwB,KAAK5P,SAAS,EAC7C,IAAI,CAAC4P,wBAAwB,GAAI/P,OAAO,CAAC+P,wBAAwB,IAAI,IAAK;;EAE9E;EACA,IAAG/P,OAAO,CAACgQ,KAAK,KAAK7P,SAAS,EAC1B,IAAI,CAAC6P,KAAK,GAAIhQ,OAAO,CAACgQ,KAAK,IAAI,IAAK;;EAExC;EACA,IAAGhQ,OAAO,CAACkR,SAAS,KAAK/Q,SAAS,EAC9B,IAAI,CAAC+Q,SAAS,GAAIlR,OAAO,CAACkR,SAAS,IAAI,IAAK;;EAEhD;EACA,IAAGlR,OAAO,CAACkS,aAAa,KAAK/R,SAAS,IAAIH,OAAO,CAACkS,aAAa,EAC3D,IAAI,CAACA,aAAa,CAAClS,OAAO,CAACkS,aAAa,CAAC;EAE7C9R,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAAC,IAAI,CAAC6J,IAAI,EAAE,IAAI,CAACxJ,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACkJ,QAAQ,CAAC;EAC/F,IAAI,CAAC5B,oBAAoB,CAACsD,KAAK,CAAC,IAAI,CAACnL,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAC,IAAI,CAACsI,cAAc,CAAC;EAEjF,IAAG,IAAI,CAACzF,UAAU,CAACkM,YAAY,CAACC,OAAO,IAAI,IAAI,CAACnM,UAAU,CAAC7G,KAAK,KAAKe,SAAS,EAAE;IAC5E,IAAI,CAACkS,QAAQ,GAAI,IAAI,CAACpM,UAAU,CAAC7G,KAAK,CAACkT,GAAG,CAACD,QAAQ,CAAC;MAAEE,SAAS,EAAE;QAAE5F,KAAK,EAAE,CAAC;QAAE6F,KAAK,EAAE;MAAQ,CAAC;MAAEC,SAAS,EAAE;QAAED,KAAK,EAAE;MAAS;IAAE,CAAC,CAAC;IAChI,IAAI,CAACH,QAAQ,CAACK,QAAQ,CAAC,IAAI,CAAC;EAChC;EAEA,OAAO,IAAI;AACf;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASzC,SAASA,CAACpB,aAAa,EAAE;EACrC,IAAG,IAAI,CAACwD,QAAQ,KAAKlS,SAAS,IAAI,CAAC,IAAI,CAAC8F,UAAU,CAACkM,YAAY,CAACC,OAAO,EACnE,OAAO,IAAI;;EAEf;EACA,IAAI,CAACC,QAAQ,CAACM,KAAK,CAAC,CAAC;EAErB,IAAG,CAAC,IAAI,CAAC1M,UAAU,CAACkM,YAAY,CAAC1D,IAAI,EACjC,OAAO,IAAI;EAEf,IAAG,IAAI,CAACxI,UAAU,CAACkM,YAAY,CAACE,QAAQ,CAAC1P,GAAG,EAAE;IAC1C,IAAI,CAAC0P,QAAQ,CAACE,SAAS,CAAC,CAAC,EAAE,IAAI,CAACtM,UAAU,CAACkM,YAAY,CAACE,QAAQ,CAAC1P,GAAG,CAAC;IAAC,IAAAuC,SAAA,GAAAC,0BAAA,CAE9C0J,aAAa;MAAAzJ,KAAA;IAAA;MAArC,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAuC;QAAA,IAA/B8B,YAAY,GAAAjC,KAAA,CAAAtF,KAAA;QAChB,IAAI,CAACuS,QAAQ,CAACO,eAAe,CAAC;UAC1BtI,EAAE,EAAE,IAAI,CAACpG,MAAM,CAACjB,CAAC;UACjBsH,EAAE,EAAE,IAAI,CAACrG,MAAM,CAACd,CAAC;UACjBoH,EAAE,EAAEnD,YAAY,CAACpE,CAAC;UAClBwH,EAAE,EAAEpD,YAAY,CAACjE;QACrB,CAAC,CAAC;MACN;IAAC,SAAAqC,GAAA;MAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;IAAA;MAAAP,SAAA,CAAAS,CAAA;IAAA;EACL;EAEA,IAAG,IAAI,CAACM,UAAU,CAACkM,YAAY,CAACE,QAAQ,CAACQ,QAAQ,EAAE;IAC/C,IAAI,CAACR,QAAQ,CAACI,SAAS,CAAC,IAAI,CAACxM,UAAU,CAACkM,YAAY,CAACE,QAAQ,CAACQ,QAAQ,CAAC;IAEvE,IAAI,CAACR,QAAQ,CAACS,SAAS,CAAC,IAAI,CAAC5O,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,CAAC,CAAC;IAAC,IAAAwC,UAAA,GAAAT,0BAAA,CAEjC0J,aAAa;MAAAhJ,MAAA;IAAA;MAArC,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAAuC;QAAA,IAA/B8B,aAAY,GAAAxB,MAAA,CAAA/F,KAAA;QAChB,IAAI,CAACuS,QAAQ,CAACS,SAAS,CAACzL,aAAY,CAACpE,CAAC,EAAEoE,aAAY,CAACjE,CAAC,EAAE,CAAC,CAAC;MAC9D;IAAC,SAAAqC,GAAA;MAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;IAAA;MAAAG,UAAA,CAAAD,CAAA;IAAA;EACL;EAEA,OAAO,IAAI;AACf;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,SAASpD,OAAOA,CAAA,EAAG;EACvB,IAAG,IAAI,CAAC8P,QAAQ,EACZ,IAAI,CAACA,QAAQ,CAAC9P,OAAO,CAAC,CAAC;EAE3B,KAAI,IAAI1C,GAAG,IAAI,IAAI,EAAE;IACjB,OAAO,IAAI,CAACA,GAAG,CAAC;EACpB;AACH;;;;;;;;;;;;;;;ACfD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASqS,aAAaA,CAAA,EAAkB;EAAA,IAAjB5Q,IAAI,GAAArB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,QAAQ;EAEzC,IAAG,IAAI,CAACsJ,IAAI,KAAKpJ,SAAS,EACtB,OAAO,IAAI;EAEf,IAAI,CAAC4S,eAAe,GAAG,IAAI,CAAC9M,UAAU,CAAC7G,KAAK,CAACkT,GAAG,CAAC5Q,MAAM,CAAC,IAAI,CAACwC,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAAC6O,cAAc,CAAC;EAC1G,IAAI,CAACc,eAAe,CAACrF,IAAI,GAAG,IAAI;EAEhC,IAAGpM,IAAI,KAAK,QAAQ,EAAE;IAClB,IAAI,CAAC0R,QAAQ,GAAG,QAAQ;IAExB,IAAG,IAAI,CAACf,cAAc,IAAI7R,MAAM,CAACgE,IAAI,CAACuH,gBAAgB,EAAE;MACpD,IAAI9B,MAAM,GAAG,IAAI,CAAC5D,UAAU,CAAC7E,WAAW;MACxC,IAAI,CAAC6E,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAAC0H,GAAG,CAACW,UAAU,CAAC,IAAI,CAACF,eAAe,EAAE;QAAEG,KAAK,EAAE;UAAE5R,IAAI,EAAE,WAAW;UAAE2B,CAAC,EAAC4G,MAAM,CAACjJ,SAAS,CAACuS,OAAO;UAAE/P,CAAC,EAACyG,MAAM,CAACjJ,SAAS,CAACwS,OAAO;UAAEzG,KAAK,EAAC9C,MAAM,CAACjJ,SAAS,CAAC+L,KAAK;UAAED,MAAM,EAAC7C,MAAM,CAACjJ,SAAS,CAAC8L;QAAO,CAAC;QAAE2G,KAAK,EAAE,2BAA2B;QAAEC,QAAQ,EAAE,IAAI;QAAEC,aAAa,EAAC;MAAK,CAAC,CAAC;IACrS,CAAC,MACI;MACD,IAAI,CAACtN,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAAC0H,GAAG,CAACW,UAAU,CAAC,IAAI,CAACF,eAAe,EAAE;QAAEG,KAAK,EAAE;UAAE5R,IAAI,EAAE;QAAS,CAAC;QAAE+R,KAAK,EAAE,2BAA2B;QAAEC,QAAQ,EAAE,IAAI;QAAEC,aAAa,EAAC;MAAK,CAAC,CAAC;IAC5K;IAEA,IAAI,CAAChK,IAAI,GAAG,IAAI,CAACwJ,eAAe,CAACxJ,IAAI;IACrC,IAAI,CAACA,IAAI,CAACmE,IAAI,GAAG,IAAI;IACrB,IAAI,CAAC8F,kBAAkB,CAAC,CAAC;EAC7B,CAAC,MACI;IACD,IAAI,CAACR,QAAQ,GAAG,QAAQ;IACxB,IAAI,CAAC/M,UAAU,CAAC7G,KAAK,CAACqU,OAAO,CAACnB,GAAG,CAACoB,QAAQ,CAAC,IAAI,CAACX,eAAe,CAAC;IAEhE,IAAI,CAACxJ,IAAI,GAAG,IAAI,CAACwJ,eAAe,CAACxJ,IAAI;IACrC,IAAI,CAACA,IAAI,CACJoK,SAAS,CAAC,IAAI,CAAC1B,cAAc,CAAC,CAC9B2B,eAAe,CAAC,KAAK,CAAC,CACtBC,YAAY,CAAC,IAAI,CAAC;IACvB,IAAI,CAACtK,IAAI,CAACmE,IAAI,GAAG,IAAI;EACzB;EAEA,OAAO,IAAI;AACf;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASoG,oBAAoBA,CAAChU,KAAK,EAAE;EACxC,IAAI,CAACyJ,IAAI,CAACwK,eAAe,CAACC,QAAQ,GAAGlU,KAAK;EAE1C,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASmU,iBAAiBA,CAACnU,KAAK,EAAE;EACrC,IAAI,CAACyJ,IAAI,CAACwK,eAAe,CAACG,KAAK,GAAGpU,KAAK;EAEvC,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,SAASqU,eAAeA,CAACC,UAAU,EAAE;EACxC,IAAIC,KAAK,GAAG,CAAC;EAEb,IAAI,CAACC,KAAK,CAACC,OAAO,CAACH,UAAU,CAAC,EAC9B;IACIC,KAAK,GAAGD,UAAU;EACtB,CAAC,MAED;IACI,KAAK,IAAItO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsO,UAAU,CAAClU,MAAM,EAAE4F,CAAC,EAAE,EAC1C;MACIuO,KAAK,IAAID,UAAU,CAACtO,CAAC,CAAC;IAC1B;EACJ;EAEA,IAAI,CAACyD,IAAI,CAACwK,eAAe,CAACS,IAAI,GAAGH,KAAK;EAEtC,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,YAAYA,CAACC,QAAQ,EAAE;EACnC,IAAIC,IAAI,GAAG,IAAI;EACf,IAAI,CAACpL,IAAI,CAACqL,iBAAiB,GAAG,UAASC,aAAa,EAAE;IAClD,IAAGA,aAAa,CAACC,WAAW,EAAE;MAC1BJ,QAAQ,CAACG,aAAa,CAAC;IAC3B,CAAC,MACI,IAAGF,IAAI,CAACI,cAAc,CAACF,aAAa,CAAC,EAAE;MACxCA,aAAa,CAACC,WAAW,GAAG,IAAI;MAChCJ,QAAQ,CAACG,aAAa,CAAC;IAC3B;EACJ,CAAC;EAED,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,eAAeA,CAACN,QAAQ,EAAE;EACtC,IAAI,CAACnL,IAAI,CAAC0L,oBAAoB,GAAG,UAASJ,aAAa,EAAE;IACrD,IAAGA,aAAa,CAACC,WAAW,EAAE;MAC1BD,aAAa,CAACC,WAAW,GAAG,KAAK;MACjCJ,QAAQ,CAACG,aAAa,CAAC;IAC3B;EACJ,CAAC;EAED,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASrB,kBAAkBA,CAACkB,QAAQ,EAAE;EACzC,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIO,IAAI,GAAG,SAAPA,IAAIA,CAAYL,aAAa,EAAE;IAC/B,IAAGF,IAAI,CAACI,cAAc,CAACF,aAAa,CAAC,EAAE;MACnC,IAAItL,IAAI,GAAGsL,aAAa,CAACM,KAAK,CAAC9B,KAAK,KAAK,2BAA2B,GAAGwB,aAAa,CAACO,KAAK,GAAGP,aAAa,CAACM,KAAK;MAEhH,IAAGN,aAAa,CAACC,WAAW,KAAK,IAAI,EAAE;QACnCD,aAAa,CAACC,WAAW,GAAG,IAAI;QAChC,IAAGH,IAAI,CAACpL,IAAI,CAACqL,iBAAiB,EAAE;UAC5BD,IAAI,CAACpL,IAAI,CAACqL,iBAAiB,CAACC,aAAa,CAAC;QAC9C;QAEA,IAAGF,IAAI,CAACpL,IAAI,CAAC8L,aAAa,KAAKlV,SAAS,IAAIwU,IAAI,CAACpL,IAAI,CAAC8L,aAAa,CAAC9L,IAAI,CAAC+L,EAAE,CAAC,EAAE;UAC1EX,IAAI,CAACpL,IAAI,CAAC8L,aAAa,CAAC9L,IAAI,CAAC+L,EAAE,CAAC,CAAC/L,IAAI,EAAEsL,aAAa,CAAC;QACzD;MACJ;MACA,IAAGH,QAAQ,EACPA,QAAQ,CAACG,aAAa,CAAC;IAC/B,CAAC,MACI;MACD,IAAGF,IAAI,CAACpL,IAAI,CAAC0L,oBAAoB,IAAIJ,aAAa,CAACC,WAAW,KAAK,IAAI,EAAE;QACrEH,IAAI,CAACpL,IAAI,CAAC0L,oBAAoB,CAACJ,aAAa,CAAC;MACjD;IACJ;EACJ,CAAC;EAED,IAAI,CAACtL,IAAI,CAACgM,uBAAuB,GAAGL,IAAI;EAExC,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASM,gBAAgBA,CAACjM,IAAI,EAAEmL,QAAQ,EAAE;EAC7C,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIO,IAAI,GAAG,SAAPA,IAAIA,CAAY3L,IAAI,EAAEsL,aAAa,EAAE;IACrC,IAAGA,aAAa,CAACC,WAAW,EAAE;MAC1BJ,QAAQ,CAACnL,IAAI,EAAEsL,aAAa,CAAC;IACjC,CAAC,MACI,IAAGF,IAAI,CAACI,cAAc,CAACF,aAAa,CAAC,EAAE;MACxCA,aAAa,CAACC,WAAW,GAAG,IAAI;MAChCJ,QAAQ,CAACnL,IAAI,EAAEsL,aAAa,CAAC;IACjC;EACJ,CAAC;EAED,IAAI,CAACP,KAAK,CAACC,OAAO,CAAChL,IAAI,CAAC,EACxB;IACIA,IAAI,GAAG,CAAEA,IAAI,CAAE;EACnB;EAEA,KAAK,IAAIzD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyD,IAAI,CAACrJ,MAAM,EAAE4F,CAAC,EAAE,EACpC;IACI,IAAI2P,GAAG,GAAIlM,IAAI,CAACzD,CAAC,CAAC,CAAC4P,cAAc,CAAC,MAAM,CAAC,GAAInM,IAAI,CAACzD,CAAC,CAAC,CAACyD,IAAI,GAAGA,IAAI,CAACzD,CAAC,CAAC;IAEnE,IAAI,CAACyD,IAAI,CAACiM,gBAAgB,CAACC,GAAG,EAAEP,IAAI,CAAC;EACzC;EAEA,OAAO,IAAI;AACf;AAAC;;;;;;;;;;;;;;;AC5ND;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASjT,SAASA,CAACgB,CAAC,EAAEG,CAAC,EAAE;EAC5B,IAAI,CAACc,MAAM,CAACmL,KAAK,CAACpM,CAAC,EAAEG,CAAC,CAAC;EACvBhD,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAAC,IAAI,CAAC6J,IAAI,EAAE,IAAI,CAACxJ,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACkJ,QAAQ,CAAC;EAC/F,IAAI,CAAC5B,oBAAoB,CAACsD,KAAK,CAAC,IAAI,CAACnL,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAC,IAAI,CAACsI,cAAc,CAAC;EAEjF,IAAG,IAAI,CAACsH,QAAQ,KAAK,QAAQ,IAAI,IAAI,CAACf,cAAc,KAAK7R,MAAM,CAACgE,IAAI,CAACuH,gBAAgB,EAAE;IACnF,IAAI,CAACoH,eAAe,CAAC9P,CAAC,GAAGA,CAAC;IAC1B,IAAI,CAAC8P,eAAe,CAAC3P,CAAC,GAAGA,CAAC;EAC9B,CAAC,MACI,IAAG,IAAI,CAAC4P,QAAQ,KAAK,QAAQ,EAAE;IAChC,IAAI,CAACD,eAAe,CAAC9P,CAAC,GAAGA,CAAC;IAC1B,IAAI,CAAC8P,eAAe,CAAC3P,CAAC,GAAGA,CAAC;EAC9B;EAEA,OAAO,IAAI;AACf;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASuS,OAAOA,CAAC1G,OAAO,EAAE;EAC7B,IAAI2G,OAAO,GAAG,EAAE;EAChB,IAAIC,aAAa,GAAG,IAAIzV,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAAC,IAAI,CAACrE,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAAC6O,cAAc,CAAC;;EAE7F;EACA,IAAG,IAAI,CAACe,QAAQ,KAAK,QAAQ,EAAE;IAC3B,IAAI8C,eAAe,GAAG,KAAK;IAC3B,IAAG7G,OAAO,KAAK9O,SAAS,EAAE;MACtB8O,OAAO,GAAG,IAAI,CAAChJ,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAACmL,KAAK,CAACC,QAAQ,CAAC,IAAI,CAACzM,IAAI,EAAE,IAAI,CAACtD,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAACqL,eAAe,CAAC,CAAC,CAAC;MAAC,IAAA/Q,SAAA,GAAAC,0BAAA,CAE/F8J,OAAO;QAAA7J,KAAA;MAAA;QAAzB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA2B;UAAA,IAAnB7E,MAAM,GAAA0E,KAAA,CAAAtF,KAAA;UACV,IAAIyJ,IAAI,GAAG7I,MAAM,CAACyU,KAAK,KAAK,IAAI,CAAC5L,IAAI,GAAG7I,MAAM,CAAC0U,KAAK,GAAG1U,MAAM,CAACyU,KAAK;UAEnE,IAAG,IAAI,CAACe,iBAAiB,CAAC3M,IAAI,CAAC,EAC3BqM,OAAO,CAAChR,IAAI,CAAC2E,IAAI,CAAC;QAC1B;MAAC,SAAA9D,GAAA;QAAAP,SAAA,CAAAQ,CAAA,CAAAD,GAAA;MAAA;QAAAP,SAAA,CAAAS,CAAA;MAAA;IACL;IACA;IAAA,KACK;MACD,IAAG,CAAC2O,KAAK,CAACC,OAAO,CAACtF,OAAO,CAAC,EACtBA,OAAO,GAAG,CAACA,OAAO,CAAC;MAAC,IAAArJ,UAAA,GAAAT,0BAAA,CAEN8J,OAAO;QAAApJ,MAAA;MAAA;QAAzB,KAAAD,UAAA,CAAAP,CAAA,MAAAQ,MAAA,GAAAD,UAAA,CAAAN,CAAA,IAAAC,IAAA,GAA2B;UAAA,IAAnB7E,OAAM,GAAAmF,MAAA,CAAA/F,KAAA;UACV,IAAGY,OAAM,KAAK,IAAI,CAAC6I,IAAI,EACnB;UAEJ,IAAG,IAAI,CAAC2M,iBAAiB,CAACxV,OAAM,CAAC,EAC7BkV,OAAO,CAAChR,IAAI,CAAClE,OAAM,CAAC;QAC5B;MAAC,SAAA+E,GAAA;QAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;MAAA;QAAAG,UAAA,CAAAD,CAAA;MAAA;IACL;EACJ;EACA;EAAA,KACK;IACD,IAAIgE,MAAM,GAAG,KAAK;IAClB;IACA,IAAGsF,OAAO,KAAK9O,SAAS,EAAE;MACtB8O,OAAO,GAAG,IAAI,CAAChJ,UAAU,CAAC7G,KAAK,CAACqU,OAAO,CAAC0C,WAAW,CAAC,IAAI,CAACjS,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAAC6O,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC;MAClHtI,MAAM,GAAG,IAAI;IACjB;IACA;IAAA,KACK,IAAG,CAAC2K,KAAK,CAACC,OAAO,CAACtF,OAAO,CAAC,EAAE;MAC7BA,OAAO,GAAG,CAACA,OAAO,CAAC;IACvB;IACA;IACA,IAAGtF,MAAM,EAAE;MAAA,IAAAzC,UAAA,GAAA/B,0BAAA,CACS8J,OAAO;QAAA9H,MAAA;MAAA;QAAvB,KAAAD,UAAA,CAAA7B,CAAA,MAAA8B,MAAA,GAAAD,UAAA,CAAA5B,CAAA,IAAAC,IAAA,GAAyB;UAAA,IAAjBgE,KAAI,GAAApC,MAAA,CAAArH,KAAA;UACR,IAAGyJ,KAAI,KAAK,IAAI,CAACA,IAAI,EACjB;UAEJ,IAAI6M,MAAM;UACV;UACA,IAAG7M,KAAI,CAAC8M,QAAQ,EAAE;YACdD,MAAM,GAAG,IAAIhW,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAACgB,KAAI,CAACE,QAAQ,CAACxG,CAAC,GAAGsG,KAAI,CAAC+M,SAAS,EAAE/M,KAAI,CAACE,QAAQ,CAACrG,CAAC,GAAGmG,KAAI,CAAC+M,SAAS,EAAE/M,KAAI,CAAC+M,SAAS,CAAC;UACvH,CAAC,MACI;YACDF,MAAM,GAAG,IAAIhW,MAAM,CAAC2C,IAAI,CAAC+H,SAAS,CAACvB,KAAI,CAACtG,CAAC,EAAEsG,KAAI,CAACnG,CAAC,EAAEmG,KAAI,CAACoD,KAAK,EAAEpD,KAAI,CAACmD,MAAM,CAAC;UAC/E;UAEA,IAAG,IAAI,CAAC6J,iBAAiB,CAACH,MAAM,CAAC,EAC7BR,OAAO,CAAChR,IAAI,CAAC2E,KAAI,CAAC0J,UAAU,CAAC;QACrC;MAAC,SAAAxN,GAAA;QAAAyB,UAAA,CAAAxB,CAAA,CAAAD,GAAA;MAAA;QAAAyB,UAAA,CAAAvB,CAAA;MAAA;IACL;IACA;IAAA,KACK;MAAA,IAAAiC,UAAA,GAAAzC,0BAAA,CACiB8J,OAAO;QAAApH,MAAA;MAAA;QAAzB,KAAAD,UAAA,CAAAvC,CAAA,MAAAwC,MAAA,GAAAD,UAAA,CAAAtC,CAAA,IAAAC,IAAA,GAA2B;UAAA,IAAnB7E,QAAM,GAAAmH,MAAA,CAAA/H,KAAA;UACV,IAAGY,QAAM,CAAC6I,IAAI,KAAKpJ,SAAS,EACxB;UAEJ,IAAIiW,OAAM;UACV;UACA,IAAG1V,QAAM,CAAC6I,IAAI,CAAC8M,QAAQ,EAAE;YACrBD,OAAM,GAAG,IAAIhW,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAAC7H,QAAM,CAAC6I,IAAI,CAACE,QAAQ,CAACxG,CAAC,GAAGvC,QAAM,CAAC6I,IAAI,CAAC+M,SAAS,EAAE5V,QAAM,CAAC6I,IAAI,CAACE,QAAQ,CAACrG,CAAC,GAAG1C,QAAM,CAAC6I,IAAI,CAAC+M,SAAS,EAAE5V,QAAM,CAAC6I,IAAI,CAAC+M,SAAS,CAAC;YACtJ,IAAG,CAAClW,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACyP,cAAc,CAACX,aAAa,EAAEO,OAAM,CAAC,EAC5D;UACR,CAAC,MACI;YACDA,OAAM,GAAG,IAAIhW,MAAM,CAAC2C,IAAI,CAAC+H,SAAS,CAACpK,QAAM,CAAC6I,IAAI,CAACtG,CAAC,EAAEvC,QAAM,CAAC6I,IAAI,CAACnG,CAAC,EAAE1C,QAAM,CAAC6I,IAAI,CAACoD,KAAK,EAAEjM,QAAM,CAAC6I,IAAI,CAACmD,MAAM,CAAC;YACvG,IAAG,CAACtM,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC0P,iBAAiB,CAACZ,aAAa,EAAEO,OAAM,CAAC,EAC/D;UACR;UAEA,IAAG,IAAI,CAACG,iBAAiB,CAACH,OAAM,CAAC,EAC7BR,OAAO,CAAChR,IAAI,CAAClE,QAAM,CAAC;QAC5B;MAAC,SAAA+E,GAAA;QAAAmC,UAAA,CAAAlC,CAAA,CAAAD,GAAA;MAAA;QAAAmC,UAAA,CAAAjC,CAAA;MAAA;IACL;EACJ;EAEA,OAAOiQ,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASb,cAAcA,CAAC2B,OAAO,EAAEC,OAAO,EAAE;EAC7C,IAAIC,IAAI,EAAEC,IAAI,EAAE7H,MAAM;EACtB;EACA,IAAG0H,OAAO,CAACvB,KAAK,KAAKhV,SAAS,IAAIuW,OAAO,CAACtB,KAAK,KAAKjV,SAAS,EAAE;IAC3DyW,IAAI,GAAGF,OAAO,CAACvB,KAAK;IACpB0B,IAAI,GAAGH,OAAO,CAACtB,KAAK;EACxB,CAAC,MACI;IACDwB,IAAI,GAAGF,OAAO;IACdG,IAAI,GAAGF,OAAO;EAClB;EAEA,IAAGC,IAAI,CAAClJ,IAAI,KAAKvN,SAAS,IAAIyW,IAAI,CAAClJ,IAAI,KAAK,IAAI,EAC5CsB,MAAM,GAAG6H,IAAI,CAAC,KACb,IAAGA,IAAI,CAACnJ,IAAI,KAAKvN,SAAS,IAAI0W,IAAI,CAACnJ,IAAI,KAAK,IAAI,EACjDsB,MAAM,GAAG4H,IAAI,CAAC,KAEd,OAAO,KAAK;EAEhB,OAAQ,IAAI,CAACjB,OAAO,CAAC3G,MAAM,CAAC,CAAC9O,MAAM,GAAG,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASqW,iBAAiBA,CAACH,MAAM,EAAE;EACtC,IAAIT,OAAO,GAAG,KAAK;;EAEnB;EAAA,IAAA7N,UAAA,GAAA3C,0BAAA,CACiB,IAAI,CAACgM,mBAAmB;IAAApJ,MAAA;EAAA;IAAzC,KAAAD,UAAA,CAAAzC,CAAA,MAAA0C,MAAA,GAAAD,UAAA,CAAAxC,CAAA,IAAAC,IAAA,GAA2C;MAAA,IAAnCiG,KAAK,GAAAzD,MAAA,CAAAjI,KAAA;MACT;MACA,IAAGsW,MAAM,CAAC9U,IAAI,IAAI,CAAC,EAAE;QACjBqU,OAAO,GAAGvV,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC+P,gBAAgB,CAACtL,KAAK,EAAE4K,MAAM,CAAC;MACpE;MACA;MAAA,KACK;QACDT,OAAO,GAAGvV,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACgQ,mBAAmB,CAACX,MAAM,EAAE5K,KAAK,CAAC;MACvE;MAEA,IAAGmK,OAAO,EAAE;QACR,OAAO,IAAI;MACf;IACJ;EAAC,SAAAlQ,GAAA;IAAAqC,UAAA,CAAApC,CAAA,CAAAD,GAAA;EAAA;IAAAqC,UAAA,CAAAnC,CAAA;EAAA;EAED,OAAO,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASuQ,iBAAiBA,CAACxV,MAAM,EAAE;EACtC,IAAI6I,IAAI;EAER,IAAG7I,MAAM,CAACY,IAAI,KAAK,MAAM,EACrBiI,IAAI,GAAG7I,MAAM,CAAC,KACb,IAAGA,MAAM,CAAC6I,IAAI,KAAKpJ,SAAS,EAC7BoJ,IAAI,GAAG7I,MAAM,CAAC6I,IAAI,CAAC,KAEnB,OAAO,KAAK;;EAEhB;EACA,IAAIQ,KAAK,GAAGR,IAAI,CAACQ,KAAK,CAAC7J,MAAM,GAAG,CAAC,GAAGqJ,IAAI,CAACQ,KAAK,CAACT,MAAM,CAAC,CAAC,CAAC,GAAGC,IAAI,CAACQ,KAAK;EACrE;EAAA,IAAAvB,UAAA,GAAArD,0BAAA,CACgB4E,KAAK;IAAAtB,MAAA;EAAA;IAArB,KAAAD,UAAA,CAAAnD,CAAA,MAAAoD,MAAA,GAAAD,UAAA,CAAAlD,CAAA,IAAAC,IAAA,GAAuB;MAAA,IAAfyR,IAAI,GAAAvO,MAAA,CAAA3I,KAAA;MACR,IAAImI,MAAM,GAAG+O,IAAI,CAAChN,QAAQ,CAAC,CAAC,CAAC;MAE7B,KAAI,IAAIlE,CAAC,GAAG,CAAC,EAAE5F,MAAM,GAAG8W,IAAI,CAAChN,QAAQ,CAAC9J,MAAM,EAAE4F,CAAC,GAAG5F,MAAM,EAAE4F,CAAC,EAAE,EAAE;QAC3D,IAAIqC,MAAM,GAAG6O,IAAI,CAAChN,QAAQ,CAAClE,CAAC,CAAC;QAC7B,IAAIkC,QAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACyE,MAAM,CAAChF,CAAC,EAAEgF,MAAM,CAAC7E,CAAC,EAAE+E,MAAM,CAAClF,CAAC,EAAEkF,MAAM,CAAC/E,CAAC,CAAC;;QAE1E;QAAA,IAAA+J,UAAA,GAAAhI,0BAAA,CACiB,IAAI,CAACgM,mBAAmB;UAAA/D,MAAA;QAAA;UAAzC,KAAAD,UAAA,CAAA9H,CAAA,MAAA+H,MAAA,GAAAD,UAAA,CAAA7H,CAAA,IAAAC,IAAA,GAA2C;YAAA,IAAnCiG,KAAK,GAAA4B,MAAA,CAAAtN,KAAA;YACT,IAAI6V,QAAO,GAAGvV,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACkQ,cAAc,CAACzL,KAAK,EAAExD,QAAO,CAAC;YACnE;YACA,IAAG,CAAC2N,QAAO,EACPA,QAAO,GAAGvV,MAAM,CAAC2C,IAAI,CAACmU,QAAQ,CAACC,aAAa,CAAC3L,KAAK,EAAExD,QAAO,CAACE,SAAS,CAAC,CAAC,CAAC;YAC5E,IAAG,CAACyN,QAAO,EACPA,QAAO,GAAGvV,MAAM,CAAC2C,IAAI,CAACmU,QAAQ,CAACC,aAAa,CAAC3L,KAAK,EAAExD,QAAO,CAAC/D,SAAS,CAAC,CAAC,CAAC;YAE5E,IAAG0R,QAAO,EAAE;cACR,OAAO,IAAI;YACf;UACJ;QAAC,SAAAlQ,GAAA;UAAA0H,UAAA,CAAAzH,CAAA,CAAAD,GAAA;QAAA;UAAA0H,UAAA,CAAAxH,CAAA;QAAA;QACDsC,MAAM,GAAGE,MAAM;MACnB;;MAEA;MACA,IAAIH,OAAO,GAAG,IAAI5H,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACwT,IAAI,CAAChN,QAAQ,CAACgN,IAAI,CAAChN,QAAQ,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAAC+C,CAAC,EAAE+T,IAAI,CAAChN,QAAQ,CAACgN,IAAI,CAAChN,QAAQ,CAAC9J,MAAM,GAAG,CAAC,CAAC,CAACkD,CAAC,EAAE4T,IAAI,CAAChN,QAAQ,CAAC,CAAC,CAAC,CAAC/G,CAAC,EAAE+T,IAAI,CAAChN,QAAQ,CAAC,CAAC,CAAC,CAAC5G,CAAC,CAAC;MAC/J;MAAA,IAAAwM,UAAA,GAAAzK,0BAAA,CACgB,IAAI,CAACgM,mBAAmB;QAAAtB,MAAA;MAAA;QAAzC,KAAAD,UAAA,CAAAvK,CAAA,MAAAwK,MAAA,GAAAD,UAAA,CAAAtK,CAAA,IAAAC,IAAA,GAA2C;UAAA,IAAnCiG,MAAK,GAAAqE,MAAA,CAAA/P,KAAA;UACT,IAAI6V,SAAO,GAAGvV,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAACkQ,cAAc,CAACzL,MAAK,EAAExD,OAAO,CAAC;UAEnE,IAAG2N,SAAO,EAAE;YACR,OAAO,IAAI;UACf;QACJ;MAAC,SAAAlQ,GAAA;QAAAmK,UAAA,CAAAlK,CAAA,CAAAD,GAAA;MAAA;QAAAmK,UAAA,CAAAjK,CAAA;MAAA;IACL;EAAC,SAAAF,GAAA;IAAA+C,UAAA,CAAA9C,CAAA,CAAAD,GAAA;EAAA;IAAA+C,UAAA,CAAA7C,CAAA;EAAA;EAED,OAAO,KAAK;AAChB;;;;;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASyR,WAAWA,CAAA,EAA0C;EAAA,IAAzCzJ,QAAQ,GAAA1N,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGG,MAAM,CAACgE,IAAI,CAACuH,gBAAgB;EAC/D,IAAI,CAACgC,QAAQ,GAAGA,QAAQ;EACxBvN,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAACK,UAAU,CAAC,IAAI,CAAC6J,IAAI,EAAE,IAAI,CAACxJ,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAE,IAAI,CAACqB,KAAK,EAAE,IAAI,CAACkJ,QAAQ,CAAC;EAC/F,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS0J,iBAAiBA,CAAA,EAAqB;EAAA,IAApB3L,cAAc,GAAAzL,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAChD,IAAI,CAACyL,cAAc,GAAGA,cAAc;EACpC,IAAI,CAACK,oBAAoB,CAACsD,KAAK,CAAC,IAAI,CAACnL,MAAM,CAACjB,CAAC,EAAE,IAAI,CAACiB,MAAM,CAACd,CAAC,EAAC,IAAI,CAACsI,cAAc,CAAC;EAEjF,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS4L,iBAAiBA,CAAA,EAAgD;EAAA,IAA/CrF,cAAc,GAAAhS,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGG,MAAM,CAACgE,IAAI,CAACuH,gBAAgB;EAC3E,IAAI4L,WAAW,GAAG,IAAI,CAACtF,cAAc,IAAI7R,MAAM,CAACgE,IAAI,CAACuH,gBAAgB;EACrE,IAAI,CAACsG,cAAc,GAAGA,cAAc;EACpC,IAAI,CAACc,eAAe,CAACyE,SAAS,CAAC,IAAI,CAACvF,cAAc,CAAC;EAEnD,IAAG,IAAI,CAACe,QAAQ,KAAK,QAAQ,EAAE;IAC3B,IAAG,IAAI,CAACf,cAAc,IAAI7R,MAAM,CAACgE,IAAI,CAACuH,gBAAgB,EAAE;MACpD,IAAI9B,MAAM,GAAG,IAAI,CAAC5D,UAAU,CAAC7E,WAAW;MAExC,IAAI,CAAC6E,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAACrB,IAAI,CAAC7B,GAAG,CAAC,IAAI,CAAC6B,IAAI,EAAE;QAC7C2J,KAAK,EAAE;UACH5R,IAAI,EAAE,WAAW;UACjB2B,CAAC,EAAE4G,MAAM,CAACjJ,SAAS,CAACuS,OAAO;UAC3B/P,CAAC,EAAEyG,MAAM,CAACjJ,SAAS,CAACwS,OAAO;UAC3BzG,KAAK,EAAE9C,MAAM,CAACjJ,SAAS,CAAC+L,KAAK;UAC7BD,MAAM,EAAE7C,MAAM,CAACjJ,SAAS,CAAC8L,MAAM;UAC/BlD,YAAY,EAAC;QACjB;MACJ,CAAC,CAAC;IACN,CAAC,MACI,IAAG+N,WAAW,EAAE;MACjB,IAAI,CAACtR,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAACrB,IAAI,CAAC7B,GAAG,CAAC,IAAI,CAAC6B,IAAI,EAAE;QAC7C2J,KAAK,EAAE;UACH5R,IAAI,EAAE,QAAQ;UACd2B,CAAC,EAAE,IAAI,CAAC8P,eAAe,CAAC9P,CAAC;UACzBG,CAAC,EAAE,IAAI,CAAC2P,eAAe,CAAC3P;QAC5B,CAAC;QACDoG,YAAY,EAAE,IAAI,CAACyI,cAAc;QACjCwF,QAAQ,EAAE;MACd,CAAC,CAAC;IACN,CAAC,MACI;MACD,IAAI,CAAC1E,eAAe,CAACyE,SAAS,CAAC,IAAI,CAACvF,cAAc,CAAC;IACvD;IACA,IAAI,CAAChM,UAAU,CAAC7G,KAAK,CAACwL,MAAM,CAACrB,IAAI,CAAC7B,GAAG,CAAC,IAAI,CAAC6B,IAAI,EAAE,cAAc,EAAE,IAAI,CAAC0I,cAAc,CAAC;EACzF,CAAC,MACI,IAAG,IAAI,CAACe,QAAQ,KAAK,QAAQ,EAAE;IAChC,IAAI,CAACzJ,IAAI,CAACoK,SAAS,CAAC,IAAI,CAAC1B,cAAc,CAAC;EAC5C;EAEA,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS1B,aAAaA,CAAC7P,MAAM,EAAkB;EAAA,IAAhBmJ,MAAM,GAAA5J,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAChD,IAAG,CAAC,IAAI,CAACyL,cAAc,EACnB,OAAO,IAAI;EAEf,IAAIgM,YAAY;EAChB,IAAG7N,MAAM,EACL6N,YAAY,GAAG7N,MAAM,CAAC,KACrB;IACD,IAAGnJ,MAAM,CAACY,IAAI,KAAK,MAAM,IAAIZ,MAAM,CAACY,IAAI,KAAK,WAAW,EACpDoW,YAAY,GAAGhX,MAAM,CAAC8B,YAAY,CAAC/B,cAAc,CAAC,CAAC,CAAC,KAEpDiX,YAAY,GAAGhX,MAAM,CAAC+B,IAAI,CAACiE,GAAG,CAAC,cAAc,CAAC,CAACjG,cAAc,CAAC,CAAC;EACvE;EAEA,IAAGL,MAAM,CAAC2C,IAAI,CAACgE,UAAU,CAAC0P,iBAAiB,CAAC,IAAI,CAAC1K,oBAAoB,EAAE2L,YAAY,CAAC,EAChF,OAAO,IAAI;EAEf,OAAO,KAAK;AAChB;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,GAAGA,CAAC3X,OAAO,EAAE4I,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC3C,UAAU,GAAG2C,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC1E,MAAM,GAAG,IAAI9D,MAAM,CAAC2C,IAAI,CAACC,KAAK,CAAC,CAAC;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC0K,IAAI,GAAG,IAAItN,MAAM,CAAC2C,IAAI,CAACS,IAAI,CAAC,CAAC;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,KAAK,GAAG,CAAC;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC4M,IAAI,GAAG,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC1D,QAAQ,GAAGvN,MAAM,CAACgE,IAAI,CAACuH,gBAAgB;EAC5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACD,cAAc,GAAG,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACK,oBAAoB,GAAG,IAAI3L,MAAM,CAAC2C,IAAI,CAACwF,MAAM,CAAC,CAAC;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC0J,cAAc,GAAG7R,MAAM,CAACgE,IAAI,CAACuH,gBAAgB;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACoE,wBAAwB,GAAG,IAAI;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,KAAK,GAAG,KAAK;EAClB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkB,SAAS,GAAG,KAAK;EACtB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACrC,aAAa,GAAG,EAAE;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACsC,mBAAmB,GAAG,EAAE;;EAE7B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC6B,QAAQ,GAAG,KAAK;;EAErB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAChK,MAAM,GAAG;IACVwF,MAAM,EAAE,MAAM;IACdC,IAAI,EAAE,CAAC;IACPC,mBAAmB,EAAE,CAAC;IACtBC,gBAAgB,EAA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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/before-startup","webpack://PhaserRaycaster/webpack/startup","webpack://PhaserRaycaster/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\n* @copyright    2023 Marcin Walczak\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\n*/\n\n/**\n * Point object\n * @typedef {Object} Point\n * @property {number} x\n * @property {number} y\n */\n \n/**\n * @classdesc\n *\n * Raycaster plugin class.\n * \n * @namespace PhaserRaycaster\n * @class PhaserRaycaster\n * @extends Phaser.Plugins.ScenePlugin\n * @constructor\n * @since 0.6.0\n *\n * @param {Phaser.Scene} scene\n * @param {Phaser.Plugins.PluginManager} pluginManager\n */\n\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\n    }\n\n    /**\n    * Create Raycaster object.\n    *\n    * @method PhaserRaycaster#createRaycaster\n    * @memberof PhaserRaycaster\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\n    *\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\n    */\n    createRaycaster(options = {}) {\n        options.scene = this.scene;\n        return new this._Raycaster(options);\n    }\n}\n\n//Make sure you export the plugin for webpack to expose\nmodule.exports = PhaserRaycaster;","/**\n* Get mapped object's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\n*/\nexport function getBoundingBox() {\n    return this.object.getBounds();\n}\n","let rectangle = require('./map-rectangle-methods.js');\nlet line = require('./map-line-methods.js');\nlet polygon = require('./map-polygon-methods.js');\nlet arc = require('./map-circle-methods.js');\nlet container = require('./map-container-methods.js');\nlet tilemap = require('./map-tilemap-methods.js');\nlet matterBody = require('./map-matterBody-methods.js');\nlet segmentCount = require('./segmentsCount.js');\nlet boundingBox = require('./boundingBox.js');\n\n/**\n * Configure map.\n *\n * @method Raycaster.Map#config\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Map's congfiguration options. May include:\n * @param {object} options.object - Game object to map\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\n * \n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //object type\n    if(options.type === undefined)\n        options.type = options.object.type;\n    if(options.type === 'body' || options.type === 'composite')\n        options.type = 'MatterBody';\n    this.type = options.type;\n    \n    switch(options.type) {\n        case 'Polygon':\n            this.getPoints = polygon.getPoints;\n            this.getSegments = polygon.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = polygon.updateMap;\n            break;\n        case 'Arc':\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            this.circle = (options.segmentCount) ? false : true;\n            this.getPoints = arc.getPoints;\n            this.getSegments = arc.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = arc.updateMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'Line':\n            this.getPoints = line.getPoints;\n            this.getSegments = line.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = line.updateMap;\n            break;\n        case 'Container':\n            //container's child\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\n            //circle segments count\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\n            //transformed container's circle children\n            this._circles = [];\n            this.getPoints = container.getPoints;\n            this.getSegments = container.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = container.updateMap;\n            this._updateChildMap = container._updateChildMap;\n            this.setSegmentCount = segmentCount.setSegmentCount;\n            break;\n        case 'StaticTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'DynamicTilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'TilemapLayer':\n            //ray colliding tiles\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\n            this.getPoints = tilemap.getPoints;\n            this.getSegments = tilemap.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = tilemap.updateMap;\n            this.setCollisionTiles = tilemap.setCollisionTiles;\n            //reset tilemap origin\n            this.object.setOrigin(0,0);\n            break;\n        case 'MatterBody':\n            //force convex body (hull) mapping\n            this.forceConvex = (options.forceConvex) ? true : false;\n            //force mapping by vertices\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\n            this.circle = false;\n            this.getPoints = matterBody.getPoints;\n            this.getSegments = matterBody.getSegments;\n            this.getBoundingBox = matterBody.getBoundingBox;\n            this.updateMap = matterBody.updateMap;\n            break;\n        default:\n            this.getPoints = rectangle.getPoints;\n            this.getSegments = rectangle.getSegments;\n            this.getBoundingBox = boundingBox.getBoundingBox;\n            this.updateMap = rectangle.updateMap;\n    }\n\n    //if object is not supported\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\n        this.notSupported = true;\n    }\n\n    //dynamic map\n    this.dynamic = (options.dynamic == true) ? true : false;\n\n    //enable/disable map\n    this.active = (options.active !== undefined) ? options.active : true;\n\n    return this;\n}\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete this.object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\n/**\n* Get array of mapped circle's vertices used as rays targets.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\n*\n* @method Raycaster.Map#arc.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    if(this._points.length > 0)\n        return this._points;\n    \n    let points = [];\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\n\n    //calculate tangent rays\n    if(ray) {\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c;\n        \n        let rotation = this.object.rotation;\n        \n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            let cB = vector.getPointB();\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\n        }\n        else { \n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\n        }\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped circle's segments used to test object's intersection with ray.\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\n*\n* @method Raycaster.Map#arc.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update circles's map of points and segments.\n*\n* @method Raycaster.Map#arc.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    if(!this.segmentCount) {\n        this._points = [];\n        this._segments = [];\n        return this;\n    }\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\n\n    //get points surrounding circle\n    let points = this.object.geom.getPoints(this.segmentCount);\n    let segments = []\n\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let newPoints = [];\n        for(let point of points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            newPoints.push(vector.getPointB());\n        }\n        points = newPoints;\n    }\n    //if rotation === 0\n    else {\n        for(let point of points) {\n            point.x = point.x * this.object.scaleX + offset.x;\n            point.y = point.y * this.object.scaleY + offset.y;\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        else\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for containers*/\n/**\n* Get array of mapped container's and its children vertices used as rays targets.\n*\n* @method Raycaster.Map#container.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n* @param {boolean} [isChild] - Flag definig if it is child container.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false, isChild = false) {\n    if(!this.active)\n        return [];\n\n    let points = this._points;\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    //get tangent points of container's circles\n    if(this.segmentCount == 0 && !isChild) {\n        if(ray) {\n            //create temporary ray\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\n    \n            let tempRay = ray._raycaster.createRay({\n                origin: {\n                    x: vector.getPointB().x,\n                    y: vector.getPointB().y\n                }\n            });\n\n            //calculate tangent rays\n            let rayA = new Phaser.Geom.Line();\n            let rayB = new Phaser.Geom.Line();\n            let c;\n\n            for(let circle of this._circles) {\n                circle.points = [];\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\n\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\n\n                //ray angle\n                let angle = Phaser.Geom.Line.Angle(c);\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n                //adding tangent points\n                circle.points.push(rayA.getPointB());\n                circle.points.push(rayB.getPointB());\n                points.push(rayA.getPointB());\n                points.push(rayB.getPointB());\n            }\n        }\n    }\n    \n    return points;\n};\n\n/**\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#container.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n\n    return this._segments;\n};\n\n/**\n* Update container's and its children maps of points and segments.\n*\n* @method Raycaster.Map#container.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.1\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let container = this.object;\n    this._circles = [];\n\n    //calculate offset based on container position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n\n    let rotation = container.rotation;\n\n    if(this.mapChild) {\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\n    }\n    else {\n        //iterate through container's children\n        container.iterate(function(child){\n            this._updateChildMap(child, points, segments, rotation, offset);\n        }.bind(this));\n\n        //get children intersections\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\n            let childA = container.list[i];\n            let mapA = childA.data.get('raycasterMap');\n            \n            if(!mapA)\n                continue;\n\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\n                let childB = container.list[j];\n                let mapB = childB.data.get('raycasterMap');\n                //check if bounding boxes overlap\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\n                    continue;\n\n                //find objects intersections\n                for(let segmentA of mapA.getSegments()) {\n                    for(let segmentB of mapB.getSegments()) {\n                        let intersection = [];\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                            continue;\n                        \n                        //calculate positions after container's rotation\n                        if(rotation !== 0) {\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                            points.push(vector.getPointB());\n                        }\n                        //if rotation === 0\n                        else\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\n                    }\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n\n/**\n* Update container's child map of points and segments.\n*\n* @method Raycaster.Map#container._updateChildMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.10.3\n*\n* @param {object} [child] - Container's child object.\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\n* @param {number} [rotation] - Container's rotation.\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\n*/\nexport function _updateChildMap(child, points, segments, rotation, offset) {\n    if(!child.data)\n        child.setDataEnabled();\n\n    //if object is not supported\n    if(child.data.get('raycasterMapNotSupported'))\n        return;\n\n    //get child map\n    let map = child.data.get('raycasterMap');\n    if(!map) {\n        map = new this.constructor({\n            object: child,\n            segmentCount: this.segmentCount\n        });\n\n        if(map.notSupported) {\n            map.destroy();\n            child.data.set('raycasterMapNotSupported', true);\n            return;\n        }\n\n        child.data.set('raycasterMap', map);\n    }\n    else\n        map.updateMap();\n\n    //add child points\n    let childPoints = [];\n    for(let point of map.getPoints(false, true)) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n        //if rotation === 0\n        else\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\n\n        childPoints.push(points[points.length - 1])\n    }\n\n    //add child segments\n    for(let segment of map.getSegments()) {\n        //calculate positions after container's rotation\n        if(rotation !== 0) {\n            let pointA = segment.getPointA();\n            let pointB = segment.getPointB();\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\n        }\n        //if rotation === 0\n        else\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\n    }\n\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\n    if(map.type == 'Arc' && this.segmentCount == 0) {\n        let circleOffset = new Phaser.Geom.Point();\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\n\n        if(rotation !== 0) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            circleOffset = vector.getPointB();\n        }\n\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\n    }\n    else if(map.type === 'Container') {\n        for(let childMapCircle of map._circles) {\n            let circleOffset = new Phaser.Geom.Point();\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\n\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                circleOffset = vector.getPointB();\n            }\n\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\n        }\n    }\n}\n","/**\n * @classdesc\n *\n * Map class responsible for mapping game objects.\n *\n * @namespace Raycaster.Map\n * @class Raycaster.Map\n * @constructor\n * @since 0.6.0\n *\n * @param {object} options - Map specific configuration settings.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Map(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Map#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.9.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Mapped object's type\n    *\n    * @name Raycaster.Map#type\n    * @type {string}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.type;\n    /**\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\n    *\n    * @name Raycaster.Map#active\n    * @type {boolean}\n    * @default true\n    * @since 0.7.2\n    */\n    this.active;\n    /**\n    * If set true, map will be automatically updated on scene update event.\n    *\n    * @name Raycaster.Map_dynamic\n    * @type {boolean}\n    * @default false\n    * @since 0.6.0\n    */\n    this._dynamic = false;\n    /**\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\n    *\n    * @name Raycaster.Map#circle\n    * @type {boolean}\n    * @default false\n    * @since 0.9.0\n    */\n    this.circle = false;\n    /**\n    * Reference to mapped object.\n    *\n    * @name Raycaster.Map#object\n    * @type {object}\n    * @readonly\n    * @since 0.6.0\n    */\n    this.object;\n    /**\n    * Array of mapped object's vertices used as rays targets.\n    *\n    * @name Raycaster.Map#_points\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._points = [];\n    /**\n    * Array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @name Raycaster.Map#_segments\n    * @type {array}\n    * @private\n    * @since 0.6.0\n    */\n    this._segments = [];\n    /**\n    * Get array of mapped object's vertices used as rays targets.\n    *\n    * @method Raycaster.Map#getPoints\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\n    */\n    this.getPoints;\n    /**\n    * Get array of mapped object's segments used to test object's intersection with ray.\n    *\n    * @method Raycaster.Map#getSegments\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\n    *\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\n    */\n    this.getSegments;\n    /**\n    * Get mapped object's bounding box.\n    *\n    * @method Raycaster.Map#getBoundingBox\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.9.0\n    *\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\n    */\n    this.getBoundingBox;\n    /**\n    * Update object's map of points and segments.\n    *\n    * @method Raycaster.Map#updateMap\n    * @memberof Raycaster.Map\n    * @instance\n    * @since 0.6.0\n    *\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n    */\n    this.updateMap;\n\n    this.config(options);\n    if(!this.notSupported)\n        this.updateMap();\n\n    return this;\n};\n\nMap.prototype = {\n    config: require('./config.js').config,\n    destroy: require('./destroy.js').destroy,\n    get dynamic() {\n        return this._dynamic;\n    },\n    set dynamic(dynamic) {\n        if(this._dynamic == dynamic)\n            return this;\n    \n        if(dynamic) {\n            this._dynamic = true;\n            \n            //add object to raycaster's dynamic objects list\n            if(this._raycaster) {\n                this._raycaster.dynamicMappedObjects.push(this.object);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n        else {\n            this._dynamic = false;\n            \n            //remove object from reycasters' dynamic objects list\n            if(this._raycaster) {\n                let index = this._raycaster.dynamicMappedObjects.indexOf(this.object);\n                if(index >= 0)\n                    this._raycaster.dynamicMappedObjects.splice(index, 1);\n    \n                this._raycaster._stats.mappedObjects.dynamic = this._raycaster.dynamicMappedObjects.length;\n                this._raycaster._stats.mappedObjects.static = this._raycaster._stats.mappedObjects.total - this._raycaster._stats.mappedObjects.dynamic;\n            }\n        }\n    \n        return this;\n     }\n};\n\nMap.prototype.constructor = Map;\n","/*Map methods for lines*/\n/**\n* Get array of mapped line's vertices used as rays targets.\n*\n* @method Raycaster.Map#line.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped line's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#line.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update line's map of points and segments.\n*\n* @method Raycaster.Map#line.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    let pointA = this.object.geom.getPointA();\n    let pointB = this.object.geom.getPointB();\n\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\n        pointA = vectorA.getPointB();\n\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\n        pointB = vectorB.getPointB();\n\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\n    }\n    //if rotation === 0\n    else {\n        //set points\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\n        //set segment\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\n    }\n    \n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n","/*Map methods for matter body*/\n/**\n* Get array of mapped matter body's vertices used as rays targets.\n*\n* @method Raycaster.Map#matterBody.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n\n    //calculate tangent rays\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\n        let points = [];\n        let rayA = new Phaser.Geom.Line();\n        let rayB = new Phaser.Geom.Line();\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\n\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\n\n        //ray angle\n        let angle = Phaser.Geom.Line.Angle(c);\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\n\n        //adding tangent points\n        points.push(rayA.getPointB());\n        points.push(rayB.getPointB());\n\n        return points;\n    }\n\n    return this._points;\n};\n\n/**\n* Get array of mapped matter body's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#matterBody.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update matter body's map of points and segments.\n*\n* @method Raycaster.Map#matterBody.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\n    let bodies = [body];\n    let generateBounds = false;\n\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\n        this.circle = true;\n        this._points = points;\n        this._segments = segments;\n\n        return this;\n    }\n\n    this.circle = false;\n\n    if(body.type == 'composite')\n        bodies = body.bodies;\n\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\n        generateBounds = true;\n    }\n    \n    for(let bodyItem of bodies) {\n        //if convex body\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\n            let vertices = bodyItem.parts[0].vertices;\n\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\n\n            for(let i = 1, length = vertices.length; i < length; i++) {\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\n\n                points.push(pointB);\n\n                //add segment\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                segments.push(segment);\n            }\n\n            //closing segment\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n            segments.push(segment);\n        }\n\n        //if concave body\n        else if(bodyItem.parts.length > 1) {\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\n                let vertices = bodyItem.parts[i].vertices;\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\n\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\n                    points.push(pointA);\n\n                for(let j = 1, length = vertices.length; j < length; j++) {\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\n                    //check if segment was already added\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\n                    \n                    if(segmentIndex !== -1) {\n                        segments.splice(segmentIndex, 1);\n                        pointA = pointB;\n                        continue;\n                    }\n                    \n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\n                        points.push(pointB);\n\n                    //add segment\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n                    segments.push(segment);\n                    \n                    pointA = pointB;\n                }\n                \n                //closing segment\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\n\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\n                if(segmentIndex === undefined)\n                    segments.push(closingSegment);\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    if(generateBounds) {\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\n        body.bounds = bounds;\n    }\n\n    return this;\n};\n\n/**\n* Get matter body's bounding box.\n*\n* @method Raycaster.Map#matterBody.getBoundingBox\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.9.0\n*\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\n*/\nexport function getBoundingBox() {\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\n\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\n}\n\n","/*Map methods for polygons*/\n/**\n* Get array of mapped polygon's vertices used as rays targets.\n*\n* @method Raycaster.Map#polygon.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped polygon's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#polygon.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update polygon's map of points and segments.\n*\n* @method Raycaster.Map#polygon.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\n    //set points\n    //calculate positions after object's rotation\n    let rotation = this.object.rotation;\n    if(rotation !== 0) {\n        for(let point of this.object.geom.points) {\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n            points.push(vector.getPointB());\n        }\n    }\n    //if rotation === 0\n    else {\n        for(let point of this.object.geom.points) {\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\n        }\n    }\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        if(i+1 < length)\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \n    }\n    //if polygon is closed\n    if(this.object.closePath) {\n        let last = points.length - 1;\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for rectangles*/\n/**\n* Get array of mapped rectangle's vertices used as rays targets.\n*\n* @method Raycaster.Map#rectangle.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    return this._points;\n};\n\n/**\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#rectangle.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments() {\n    if(!this.active)\n        return [];\n    return this._segments;\n};\n\n/**\n* Update rectangle's map of points and segments.\n*\n* @method Raycaster.Map#rectangle.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.6.0\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n        \n    let points = [];\n    let segments = [];\n\n    //set points\n    points = [\n        this.object.getTopLeft(),\n        this.object.getTopRight(),\n        this.object.getBottomRight(),\n        this.object.getBottomLeft()\n    ];\n\n    //set segments\n    for(let i = 0, length = points.length; i < length; i++) {\n        let prevPoint = i > 0 ? points[i - 1] : points.slice(-1),\n            nextPoint = i < length - 1 ? points[i + 1] : points[0];\n\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, nextPoint.x, nextPoint.y));\n        points[i].intersection = new Phaser.Geom.Line(prevPoint.x, prevPoint.y, nextPoint.x, nextPoint.y);\n\n\n        /*\n        if(i+1 < length) {\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\n        }\n        else {\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\n        }\n        */\n    }\n\n    this._points = points;\n    this._segments = segments;\n\n    return this;\n};\n","/*Map methods for tilemaps*/\n/**\n* Get array of mapped tilemap's vertices used as rays targets.\n*\n* @method Raycaster.Map#tilemap.getPoints\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\n*/\nexport function getPoints(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._points;\n\n    let points = [];\n    for(let point of this._points) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\n            points.push(point);\n    }\n\n    //get intersections between tilemap's segments and ray's detection range edge\n    let segments = this.getSegments(ray);\n\n    for(let segment of segments) {\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\n        \n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\n    }\n\n    return points;\n};\n\n/**\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\n*\n* @method Raycaster.Map#tilemap.getSegments\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\n*\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\n*/\nexport function getSegments(ray = false) {\n    if(!this.active)\n        return [];\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\n        return this._segments;\n\n    let segments = [];\n    for(let segment of this._segments) {\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\n            segments.push(segment);\n        }\n    }\n\n    return segments;\n};\n\n/**\n* Update tilemap's map of points and segments.\n*\n* @method Raycaster.Map#tilemap.updateMap\n* @memberof Raycaster.Map\n* @instance\n* @private\n* @since 0.7.3\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function updateMap() {\n    if(!this.active)\n        return this;\n\n    let points = [];\n    let segments = [];\n    \n    //calculate offset based on object position and origin point\n    let offset = new Phaser.Geom.Point();\n    offset.x = this.object.x;\n    offset.y = this.object.y;\n\n    let horizontal = false;\n    let horizontals = [];\n    let verticals = [];\n\n    //iterate rows\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\n        let row = this.object.layer.data[i];\n\n        //iterate row's tiles\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\n            let tile = row[j];\n\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\n\n            //get current tile's column last vertical line\n            let vertical = false;\n            if(verticals.length <= j)\n                verticals[j] = [];\n            else if(verticals[j].length > 0)\n                vertical = verticals[j][verticals[j].length - 1];\n\n            //check if tile has edge from left\n            if(leftEdge) {\n                if(vertical && vertical.y + vertical.height == i)\n                    vertical.height++;\n                else {\n                    verticals[j].push({\n                        x: tile.x,\n                        y: tile.y,\n                        height: 1\n                    });\n                }\n            }\n\n            //check if tile has edge from top\n            if(upperEdge) {\n                if(horizontal)\n                    horizontal.width++;\n                else\n                    horizontal = {\n                        x: tile.x,\n                        y: tile.y,\n                        width: 1\n                    };\n                continue;\n            }\n\n            if(horizontal) {\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n                segments.push(segment);\n                horizontals.push(segment);\n                points.push(new Phaser.Geom.Point(x, y));\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n                horizontal = false;\n            }\n        }\n        \n        //at the end of row add segment if exist\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add bottom horizontal segments\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\n        if(this.collisionTiles.includes(tile.index)) {\n            if(horizontal)\n                horizontal.width++;\n            else\n                horizontal = {\n                    x: tile.x,\n                    y: tile.y + 1,\n                    width: 1\n                };\n            continue;\n        }\n\n        if(horizontal) {\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n            segments.push(segment);\n            horizontals.push(segment);\n            points.push(new Phaser.Geom.Point(x, y));\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n            horizontal = false;\n        }\n    }\n\n    //add segment if exist\n    if(horizontal) {\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\n        segments.push(segment);\n        horizontals.push(segment);\n        points.push(new Phaser.Geom.Point(x, y));\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\n        horizontal = false;\n    }\n    \n    //add right vertical segments\n    let vertical = false;\n    let verticalsLastColumn = [];\n    for(let row of this.object.layer.data) {\n        let tile = row[row.length - 1];\n\n        //if tile blocks ray\n        if(this.collisionTiles.includes(tile.index)) {\n            if(vertical) {\n                vertical.height++;\n            }\n            else {\n                vertical = {\n                    x: tile.x + 1,\n                    y: tile.y,\n                    height: 1\n                };\n            }\n\n            continue;\n        }\n\n        if(vertical) {\n            verticalsLastColumn.push(vertical);\n            vertical = false;\n        }\n    }\n\n    verticals.push(verticalsLastColumn);\n    \n    //add vertical segments\n    for(let column of verticals) {\n        if(!column)\n            continue;\n\n        for(let vertical of column) {\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\n            segments.push(segment);\n\n            //add points if they're not already there\n            if(!points.filter(point => point.x == x && point.y == y1))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            if(!points.filter(point => point.x == x && point.y == y2))\n                points.push(new Phaser.Geom.Point(x, y));\n\n            //get intersections between horizontal segments and vertical\n            for(let horizontalSegment of horizontals) {\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\n                    continue;\n\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\n                    continue;\n\n                let point = new Phaser.Geom.Point();\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\n                    points.push(point);\n                }\n            }\n        }\n    }\n\n    this._points = points;\n    this._segments = segments;\n    return this;\n};\n\n/**\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\n*\n* @method Raycaster.Map#setCollisionTiles\n* @memberof Raycaster.Map\n* @instance\n* @since 0.7.3\n*\n* @param {array} [tiles = []] - Set of tile's indexes to map.\n*\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n*/\nexport function setCollisionTiles(tiles = []) {\n    this.collisionTiles = tiles;\n    return this;\n}\n","/**\n * Set segment count for cirle's map.\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\n *\n * @method Raycaster.Map#setSegmentCount\n * @memberof Raycaster.Map\n * @instance\n * @since 0.6.0\n *\n * @param {number} count - Circle map's segment count.\n *\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\n */\nexport function setSegmentCount(count) {\n    this.segmentCount = count;\n    this.circle = count ? false : true;\n\n    this.updateMap();\n    return this;\n}\n","/**\n * Set ray's angle (direction) in radians.\n *\n * @method Raycaster.Ray#setAngle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [angle = 0] - Ray's angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngle(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's angle (direction) in degrees.\n *\n * @method Raycaster.Ray#setAngleDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.1\n *\n * @param {number} [angle = 0] - Ray's angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setAngleDeg(angle = 0) {\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n","/**\n * Cast ray to find closest intersection with tested mapped objects.\n *\n * @method Raycaster.Ray#cast\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\n *\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\n */\nexport function cast(options = {}) {\n    let closestIntersection;\n    let closestSegment;\n    let closestObject;\n    let closestDistance = this.rayRange;\n    let internal = options.internal ? options.internal : false;\n    let startTime = performance.now();\n    let stats = {\n        method: 'cast',\n        rays: 1,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if bounding box is defined check bounding box intersection\n    if(this._raycaster && this._raycaster.boundingBox) {\n        let intersections = [];\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\n        if(intersections.length === 1)\n            closestIntersection = intersections[0];\n        else if(intersections.length > 1) {\n            for(let intersection of intersections) {\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                if(distance < closestDistance) {\n                    closestDistance = distance;\n                    closestIntersection = intersection;\n                }\n            }\n        }\n        //if ray target is declared\n        else if(options.target){\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\n            //if target is within ray range\n            if(this.rayRange > distance) {\n                closestDistance = distance;\n                closestIntersection = options.target;\n            }\n        }\n    }\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n    \n    for(let object of options.objects) {\n        let map, boundingBox, boundingBoxIntersections = [], canTestMap = false;\n        \n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        stats.testedMappedObjects++;\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        if(internal) {\n            boundingBox = map._boundingBox;\n        }\n        else {\n            boundingBox = map.getBoundingBox();\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n        }\n\n        //check if object is intersected by ray\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox, boundingBoxIntersections).length === 0)\n            continue;\n\n        //check if bounding box is closer than closest intersection\n        for(let boundingBoxIntersection of boundingBoxIntersections) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, boundingBoxIntersection.x, boundingBoxIntersection.y) < closestDistance) {\n                canTestMap = true;\n                break;\n            }\n        }\n\n        if(!canTestMap)\n            continue;\n\n        stats.hitMappedObjects++;\n        stats.segments += map.getSegments(this).length;\n        \n        //check intersections\n        for(let segment of map.getSegments(this)) {\n            let intersection = [];\n\n            //if target point is segmemt point\n            if(options.target) {\n                if(\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\n                ) {\n                    intersection = options.target;\n                }\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n                    continue;\n            }\n            //if no intersection continue\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\n              continue;\n            \n            //get closest intersection\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n            if(distance < closestDistance) {\n                closestDistance = distance;\n                closestIntersection = intersection;\n                closestObject = map.object;\n                closestSegment = segment;\n            }\n        }\n\n        //check if map is circular\n        if(map.circle) {\n           //if circular map has generated points (besides tangent points to ray)\n            if(map._points.length > 0) {\n                continue;\n            }\n            \n            //check if target point is a circle tangent point to ray\n            if(options.target) {\n                let points = map.getPoints(this);\n                let isTangent = false;\n                for(let point of points) {\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = point;\n                            closestObject = map.object;\n                            isTangent = true;\n                            break;\n                        }\n                    }\n                }\n\n                if(isTangent)\n                    continue;\n            }\n\n            let circleIntersections = [];\n            let offset = new Phaser.Geom.Point();\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\n\n            //calculate circle's center after rotation\n            let rotation = map.object.rotation;\n            if(rotation !== 0) {\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\n                let cB = vector.getPointB();\n                offset.x = cB.x;\n                offset.y = cB.y;\n            }\n\n            //create transformed circle\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\n\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                for(let intersection of circleIntersections) {\n                    //get closest intersection\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                    if(distance < closestDistance) {\n\n                        closestDistance = distance;\n                        closestIntersection = intersection;\n                        closestObject = map.object;\n                    }\n                }\n            }\n        }\n\n        //check container map's circles\n        if(map.type == 'Container' && map._circles.length > 0) {\n            for(let circle of map._circles) {\n                //check if target point is a circle tangent point to ray\n                if(options.target) {\n                    let isTangent = false;\n\n                    for(let point of circle.points) {\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\n                            //get closest intersection\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\n\n                            if(distance < closestDistance) {\n                                closestDistance = distance;\n                                closestIntersection = point;\n                                closestObject = map.object;\n                                isTangent = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if(isTangent)\n                        continue;\n                }\n\n                let circleIntersections = [];\n\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\n                    for(let intersection of circleIntersections) {\n                        //get closest intersection\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\n\n                        if(distance < closestDistance) {\n                            closestDistance = distance;\n                            closestIntersection = intersection;\n                            closestObject = map.object;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    //update stats\n    if(internal) {\n        this._stats.rays++;\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\n        this._stats.segments += stats.segments;\n    }\n    else {\n        stats.time = performance.now() - startTime;\n        this._stats = stats;\n    }\n\n    let result;\n    if(!closestIntersection) {\n        if(this.ignoreNotIntersectedRays)\n            return false;\n\n        result = this._ray.getPointB();\n    }\n    else {\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\n        result.segment = closestSegment;\n        result.object = closestObject;\n    }\n\n    if(this.round) {\n        result.x = Math.round(result.x);\n        result.y = Math.round(result.y);\n    }\n\n    if(!internal)\n        this.drawDebug([result]);\n    \n    return result;\n}","/**\n * Cast ray in all directions to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCircle\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCircle(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCircle',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n            rayTargets.push({\n                point: point,\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\n            });\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else {\n                mapB = objectB.data.get('raycasterMap');\n            }\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    \n                    let target = {\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\n                    };\n                    target.point.intersection = false;\n                    rayTargets.push(target);\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angle - b.angle;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n\n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n\n            //tmp\n            if(castSides) {\n                if(target.point.intersection === false)\n                    castSides = false;\n                else if(target.point.intersection && Phaser.Geom.Intersects.LineToLine(this._ray, target.point.intersection))\n                    castSides = false;\n            }\n            \n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice();\n\n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Cast ray in a cone to find closest intersections with tested mapped objects.\n *\n * @method Raycaster.Ray#castCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {object} [options] - options that may include:\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\n *\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\n */\nexport function castCone(options = {}) {\n    let originalAngle = this.angle;\n    let intersections = [];\n    let maps = [];\n    let rayTargets = [];\n    let testedObjects = [];\n    let cone = this.cone;\n    let minAngle = 0;\n    let maxAngle = 0;\n    let angleOffset = 0;\n    let startTime = performance.now();\n    //reset stats\n    this._stats = {\n        method: 'castCone',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    //set cone\n    if(options.cone !== undefined)\n        cone = options.cone;\n    if(options.coneDeg !== undefined)\n        cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //set cone min and max angle\n    minAngle = this.angle - cone / 2;\n    maxAngle = this.angle + cone / 2;\n\n    //add min and max angle points\n    this.setAngle(minAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: minAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\n    });\n\n    this.setAngle(maxAngle);\n    rayTargets.push({\n        point: this._ray.getPointB(),\n        angle: maxAngle,\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\n    });\n\n    //if no objects to cast ray were passed, use raycasters mapped objects\n    if(!options.objects) {\n        if(this._raycaster)\n            options.objects = this._raycaster.mappedObjects;\n        else\n            return intersections;\n    }\n\n    //if bounding box is defined add bounding box points to \n    if(this._raycaster && this._raycaster.boundingBox) {\n        for(let point of this._raycaster.boundingBox.points) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: angle,\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n    }\n\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\n        let object = options.objects[i];\n        //if bound in range\n        if(!this.boundsInRange(object))\n            continue;\n        \n        testedObjects.push(object);\n\n        let map, boundingBox;\n        if(object.type === 'body' || object.type === 'composite')\n            map = object.raycasterMap;\n        else\n            map = object.data.get('raycasterMap');\n\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\n        boundingBox = map.getBoundingBox();\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\n\n        map._boundingBox = boundingBox;\n\n        maps.push(map);\n        //get points and angles\n        for(let point of map.getPoints(this)) {\n\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                rayTargets.push({\n                    point: point,\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\n                    angleOffsetDeg: -angleOffsetDeg\n                });\n            }\n        }\n\n        //get objects intersections\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\n            let objectB = options.objects[j];\n            let mapB;\n            if(objectB.type === 'body' || objectB.type === 'composite')\n                mapB = objectB.raycasterMap;\n            else\n                mapB = objectB.data.get('raycasterMap');\n            //check if bounding boxes overlap\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\n                continue;\n            \n            //find objects intersections\n            for(let segmentA of map.getSegments(this)) {\n                for(let segmentB of mapB.getSegments(this)) {\n                    let intersection = [];\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\n                        continue;\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\n\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\n                        rayTargets.push({\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\n                            angleOffsetDeg: -angleOffsetDeg\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    //sort target points by angle\n    rayTargets.sort(function(a, b){\n        //if rays towards points have the same angles promote closer one\n        if(a.angle == b.angle) {\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\n                return 1;\n            else\n                return -1;\n        }\n\n        return a.angleOffsetDeg - b.angleOffsetDeg;\n    }.bind(this));\n\n    let previousTarget = {\n        angle: false\n    };\n\n    //cast rays\n    for(let target of rayTargets){\n        //if current target is the same as previous one skip loop\n        if(target.angle === previousTarget.angle) {\n            continue;\n        }\n\n        previousTarget = target;\n        \n        this.setAngle(target.angle);\n        let intersection = this.cast({\n            objects: testedObjects,\n            target: target.point,\n            internal: true\n        });\n        if(intersection){\n            //if intersection hits target point cast two additional rays\n            let castSides = false;\n            if(this.round) {\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\n            }\n            else {\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\n            }\n            if(castSides) {\n                this.setAngle(target.angle - 0.0001);\n                let intersectionA = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionA) {\n                    intersections.push(intersectionA);\n                }\n\n                intersections.push(intersection);\n\n                this.setAngle(target.angle + 0.0001);\n                let intersectionB = this.cast({\n                    objects: testedObjects,\n                    internal: true\n                });\n\n                if(intersectionB) {\n                    intersections.push(intersectionB);\n                }\n\n                continue;\n            }\n\n            intersections.push(intersection);\n        }\n    }\n\n    this.setAngle(originalAngle);\n    this.intersections = intersections;\n    if(this.autoSlice)\n        this.slicedIntersections = this.slice(intersections, false);\n    \n    this._stats.time = performance.now() - startTime;\n\n    this.drawDebug(intersections);\n\n    return intersections;\n}\n","/**\n * Set ray's cone angle (width) in radians.\n *\n * @method Raycaster.Ray#setCone\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in radians.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCone(cone = 0) {\n    this.cone = cone;\n    return this;\n}\n\n/**\n * Set ray's cone angle (width) in degrees.\n *\n * @method Raycaster.Ray#setConeDeg\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.7.0\n *\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setConeDeg(cone = 0) {\n    this.cone = Phaser.Math.DegToRad(cone);\n    return this;\n}\n","/**\n * Configure ray.\n *\n * @method Raycaster.Ray#config\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function config(options) {\n    this.object = options.object;\n    //origin\n    if(options.origin !== undefined)\n        this.origin.setTo(options.origin.x, options.origin.y);\n\n    //angle\n    if(options.angle !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\n\n    //angle deg\n    if(options.angleDeg !== undefined)\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\n\n    //cone angle\n    if(options.cone !== undefined)\n        this.cone = options.cone;\n\n    //cone angle deg\n    if(options.coneDeg !== undefined)\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\n\n    //ray range (0 = max)\n    if(options.rayRange !== undefined)\n        this.rayRange = options.rayRange;\n\n    //collision range (0 = max)\n    if(options.collisionRange !== undefined)\n        this.collisionRange = options.collisionRange;\n\n    //detection range (0 = max)\n    if(options.detectionRange !== undefined)\n        this.detectionRange = options.detectionRange;\n\n    //ignore not intersected rays\n    if(options.ignoreNotIntersectedRays !== undefined)\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\n    \n    //round\n    if(options.round !== undefined)\n        this.round = (options.round == true)\n\n    //auto slice\n    if(options.autoSlice !== undefined)\n        this.autoSlice = (options.autoSlice == true)\n\n    //enable physics\n    if(options.enablePhysics !== undefined && options.enablePhysics)\n        this.enablePhysics(options.enablePhysics);\n    \n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\n        this.graphics.setDepth(1000);\n    }\n\n    return this;\n}\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10.0\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    if(this.graphics)\r\n        this.graphics.destroy();\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\n *\n * @method Raycaster.Ray#enablePhysics\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function enablePhysics(type = 'arcade') {\n    \n    if(this.body !== undefined)\n        return this;\n\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\n    this.collisionCircle._ray = this;\n\n    if(type === 'matter') {\n        this.bodyType = 'matter';\n\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n        else {\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\n        }\n\n        this.body = this.collisionCircle.body;\n        this.body._ray = this;\n        this.setOnCollideActive();\n    }\n    else {\n        this.bodyType = 'arcade';\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\n\n        this.body = this.collisionCircle.body;\n        this.body\n            .setCircle(this.collisionRange)\n            .setAllowGravity(false)\n            .setImmovable(true);\n        this.body._ray = this;\n    }\n\n    return this;\n}\n","/*Matter physics methods for ray body*/\n/**\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\n * categories are included in their collision masks (see {@link #setCollidesWith}).\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique category bitfield.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionCategory(value) {\n    this.body.collisionFilter.category = value;\n\n    return this;\n};\n\n/**\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\n * they will never collide.\n *\n * @method Raycaster.Ray#setCollisionCategory\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {number} value - Unique group index.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionGroup(value) {\n    this.body.collisionFilter.group = value;\n\n    return this;\n};\n\n/**\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\n * and `(categoryB & maskA) !== 0` are both true.*\n *\n * @method Raycaster.Ray#setCollidesWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\n\nexport function setCollidesWith(categories) {\n    var flags = 0;\n\n    if (!Array.isArray(categories))\n    {\n        flags = categories;\n    }\n    else\n    {\n        for (var i = 0; i < categories.length; i++)\n        {\n            flags |= categories[i];\n        }\n    }\n\n    this.body.collisionFilter.mask = flags;\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollide\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollide(callback) {\n    let self = this;\n    this.body.onCollideCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(collisionInfo);\n        }\n    };\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideEnd\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideEnd(callback) {\n    this.body.onCollideEndCallback = function(collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            collisionInfo.rayCollided = false;\n            callback(collisionInfo);\n        }\n    }\n\n    return this;\n};\n\n/**\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideActive\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideActive(callback) {\n    let self = this;\n    let func = function(collisionInfo) {\n        if(self.processOverlap(collisionInfo)) {\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\n\n            if(collisionInfo.rayCollided !== true) {\n                collisionInfo.rayCollided = true;\n                if(self.body.onCollideCallback) {\n                    self.body.onCollideCallback(collisionInfo);\n                }\n\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\n                    self.body.onCollideWith[body.id](body, collisionInfo);\n                }\n            }\n            if(callback)\n                callback(collisionInfo);\n        }\n        else {\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\n                self.body.onCollideEndCallback(collisionInfo);\n            }\n        }\n    }\n\n    this.body.onCollideActiveCallback = func;\n\n    return this;\n}\n\n/**\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\n * \n * This does not change the bodies collision category, group or filter. Those must be set in addition\n * to the callback.\n *\n * @method Raycaster.Ray#setOnCollideWith\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.9.1\n *\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\n * \n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOnCollideWith(body, callback) {\n    let self = this;\n    let func = function(body, collisionInfo) {\n        if(collisionInfo.rayCollided) {\n            callback(body, collisionInfo);\n        }\n        else if(self.processOverlap(collisionInfo)) {\n            collisionInfo.rayCollided = true;\n            callback(body, collisionInfo);\n        }\n    }\n\n    if (!Array.isArray(body))\n    {\n        body = [ body ];\n    }\n\n    for (var i = 0; i < body.length; i++)\n    {\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\n\n        this.body.setOnCollideWith(src, func);\n    }\n\n    return this;\n};\n","/**\n * Set ray's source position.\n *\n * @method Raycaster.Ray#setOrigin\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setOrigin(x, y) {\n    this.origin.setTo(x, y);\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n    else if(this.bodyType === 'arcade') {\n        this.collisionCircle.x = x;\n        this.collisionCircle.y = y;\n    }\n\n    return this;\n}\n","/**\n * Get game objects overlaping field of view.\n *\n * @method Raycaster.Ray#overlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\n *\n * @return {object[]} Array of game objects that overlaps with field of view.\n */\nexport function overlap(objects) {\n    let targets = [];\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\n\n    //matter physics\n    if(this.bodyType === 'matter') {\n        let isCollisionInfo = false;\n        if(objects === undefined) {\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\n\n            for(let object of objects) {   \n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\n\n                if(this.testMatterOverlap(body))\n                    targets.push(body);\n            }\n        }\n        //get object's body\n        else {\n            if(!Array.isArray(objects))\n                objects = [objects];\n            \n            for(let object of objects) {\n                if(object === this.body)\n                    continue;\n    \n                if(this.testMatterOverlap(object))\n                    targets.push(object);\n            }\n        }\n    }\n    //arcade physics\n    else {\n        let bodies = false;\n        //get bodies in range\n        if(objects === undefined) {\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\n            bodies = true;\n        }\n        //get object's body\n        else if(!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        //if objects are bodies\n        if(bodies) {\n            for(let body of objects) {\n                if(body === this.body)\n                    continue;\n            \n                let hitbox;\n                //get physics body hitbox\n                if(body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(body.gameObject);\n            }\n        }\n        //if objects are game objects\n        else {\n            for(let object of objects) {\n                if(object.body === undefined)\n                    continue;\n\n                let hitbox;\n                //get physics body hitbox\n                if(object.body.isCircle) {\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\n                        continue;\n                }\n                else {\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\n                        continue;\n                }\n\n                if(this.testArcadeOverlap(hitbox))\n                    targets.push(object);\n            }\n        }\n    }\n\n    return targets;\n}\n\n/**\n * Process callback for physics collider / overlap.\n *\n * @method Raycaster.Ray#processOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\n *\n * @return {boolean} Return true if game object is overlapping ray's field of view.\n */\nexport function processOverlap(object1, object2) {\n    let obj1, obj2, target;\n    //check if it's matter collisionInfo object\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\n        obj1 = object1.bodyA;\n        obj2 = object1.bodyB;\n    }\n    else {\n        obj1 = object1;\n        obj2 = object2;\n    }\n\n    if(obj1._ray !== undefined && obj1._ray === this)\n        target = obj2;\n    else if(obj2._ray !== undefined && obj2._ray === this)\n        target = obj1;\n    else\n        return false;\n\n    return (this.overlap(target).length > 0);\n}   \n\n/**\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testArcadeOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.8.0\n *\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testArcadeOverlap(hitbox) {\n    let overlap = false;\n\n    //iterate through field of view slices to check collisions with target\n    for(let slice of this.slicedIntersections) {\n        //if hitbox is a circle\n        if(hitbox.type == 0) {\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\n        }\n        //if hitbox is a rectangle\n        else {\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\n        }\n\n        if(overlap) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\n *\n * @method Raycaster.Ray#testMatterOverlap\n * @memberof Raycaster.Ray\n * @instance\n * @private\n * @since 0.9.0\n *\n * @param {object} body - Matter body.\n *\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\n */\nexport function testMatterOverlap(object) {\n    let body;\n\n    if(object.type === 'body')\n        body = object;\n    else if(object.body !== undefined)\n        body = object.body;\n    else\n        return false;\n\n    //if body is concave, ignore convex body\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\n    //iterate through bodies\n    for(let part of parts) {\n        let pointA = part.vertices[0];\n\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\n            let pointB = part.vertices[i];\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\n\n            //iterate through field of view slices to check collisions with target\n            for(let slice of this.slicedIntersections) {\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\n                if(!overlap)\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\n\n                if(overlap) {\n                    return true;\n                }\n            }\n            pointA = pointB;\n        }\n\n        //closing segment\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\n         //iterate through field of view slices to check collisions with target\n        for(let slice of this.slicedIntersections) {\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\n\n            if(overlap) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n","/**\n * Set ray's range.\n *\n * @method Raycaster.Ray#setRayRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.rayRange = rayRange;\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    return this;\n}\n\n/**\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\n * Ray tests all objects when set to 0.\n *\n * @method Raycaster.Ray#setDetectionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setDetectionRange(detectionRange = 0) {\n    this.detectionRange = detectionRange;\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\n\n    return this;\n}\n\n/**\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\n * Determines ray's physics body radius.\n *\n * @method Raycaster.Ray#setCollisionRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\n    this.collisionRange = collisionRange;\n    this.collisionCircle.setRadius(this.collisionRange);\n\n    if(this.bodyType === 'matter') {\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\n            let bounds = this._raycaster.boundingBox;\n\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'rectangle',\n                    x: bounds.rectangle.centerX,\n                    y: bounds.rectangle.centerY,\n                    width: bounds.rectangle.width,\n                    height: bounds.rectangle.height,\n                    circleRadius:0\n                }\n            });\n        }\n        else if(oldRangeMax) {\n            this._raycaster.scene.matter.body.set(this.body, {\n                shape: {\n                    type: 'circle',\n                    x: this.collisionCircle.x,\n                    y: this.collisionCircle.y\n                },\n                circleRadius: this.collisionRange,\n                isStatic: false\n            });\n        }\n        else {\n            this.collisionCircle.setRadius(this.collisionRange);\n        }\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\n    }\n    else if(this.bodyType === 'arcade') {\n        this.body.setCircle(this.collisionRange);\n    }\n\n    return this;\n}\n\n/**\n * Test if object's bounding box is in ray's detection range.\n *\n * @method Raycaster.Ray#boundsInRange\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {object} object - Tested object\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\n *\n * @return {boolean} Information if object is in ray's detection range.\n */\nexport function boundsInRange(object, bounds = false) {\n    if(!this.detectionRange)\n        return true;\n\n    let objectBounds;\n    if(bounds)\n        objectBounds = bounds;\n    else {\n        if(object.type === 'body' || object.type === 'composite')\n            objectBounds = object.raycasterMap.getBoundingBox();\n        else\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\n    }\n\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\n        return true;\n\n    return false;\n}\n","/**\n * @classdesc\n *\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\n *\n * @namespace Raycaster.Ray\n * @class Raycaster.Ray\n * @constructor\n * @since 0.6.0\n *\n * @param {object} [options] - Ray's congfiguration options. May include:\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\n * @param {number} [options.angle = 0] - Ray's angle in radians.\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\n * @param {Raycaster} [raycaster] - Parent raycaster object.\n */\nexport function Ray(options, raycaster) {\n    /**\n    * Reference to parent Raycaster object.\n    *\n    * @name Raycaster.Ray#_raycaster\n    * @type {Raycaster}\n    * @private\n    * @since 0.6.0\n    */\n    this._raycaster = raycaster ? raycaster : false;\n    /**\n    * Ray's source position.\n    *\n    * @name Raycaster.Ray#origin\n    * @type {Phaser.Geom.Point}\n    * @since 0.6.0\n    */\n    this.origin = new Phaser.Geom.Point();\n    /**\n    * Ray's representation used to calculating intersections.\n    *\n    * @name Raycaster.Ray#_ray\n    * @type {Phaser.Geom.Line}\n    * @private\n    * @since 0.6.0\n    */\n    this._ray = new Phaser.Geom.Line();\n    /**\n    * Ray's angle in radians.\n    *\n    * @name Raycaster.Ray#angle\n    * @type {number}\n    * @default 0\n    * @since 0.6.0\n    */\n    this.angle = 0;\n    /**\n    * Ray's cone width angle in radians.\n    *\n    * @name Raycaster.Ray#cone\n    * @type {number}\n    * @default 0\n    * @since 0.7.0\n    */\n    this.cone = 0;\n    /**\n    * Ray's maximum range\n    *\n    * @name Raycaster.Ray#rayRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.6.0\n    */\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\n    * Ray tests all objects when set to 0.\n    *\n    * @name Raycaster.Ray#detectionRange\n    * @type {number}\n    * @default\n    * @since 0.6.0\n    */\n    this.detectionRange = 0;\n    /**\n    * Ray's representation of detection range used in calculating if objects are in range.\n    *\n    * @name Raycaster.Ray#detectionRangeCircle\n    * @type {Phaser.Geom.Circle}\n    * @private\n    * @since 0.6.0\n    */\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\n    /**\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\n    *\n    * @name Raycaster.Ray#collisionRange\n    * @type {number}\n    * @default Phaser.Math.MAX_SAFE_INTEGER\n    * @since 0.8.0\n    */\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\n    /**\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\n    *\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\n    * @type {boolean}\n    * @default true\n    * @since 0.6.0\n    */\n    this.ignoreNotIntersectedRays = true;\n    /**\n    * If set true, ray's hit points will be rounded.\n    *\n    * @name Raycaster.Ray#round\n    * @type {boolean}\n    * @default false\n    * @since 0.8.1\n    */\n    this.round = false;\n    /**\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\n    *\n    * @name Raycaster.Ray#autoSlice\n    * @type {boolean}\n    * @default false\n    * @since 0.8.0\n    */\n    this.autoSlice = false;\n    /**\n    * Array of intersections from last raycast representing field of view.\n    *\n    * @name Raycaster.Ray#intersections\n    * @type {object[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.intersections = [];\n    /**\n    * Array of triangles representing slices of field of view from last raycast.\n    *\n    * @name Raycaster.Ray#slicedIntersections\n    * @type {Phaser.Geom.Triangle[]}\n    * @default []\n    * @since 0.8.0\n    */\n    this.slicedIntersections = [];\n\n    /**\n    * Physics body for testing field of view collisions.\n    *\n    * @name Raycaster.Ray#body\n    * @type {object}\n    * @default undefined\n    * @since 0.8.0\n    */\n    //this.body = false;\n    /**\n    * Physics body type.\n    *\n    * @name Raycaster.Ray#bodyType\n    * @type {(boolean|'arcade'|'matter')}\n    * @default false\n    * @since 0.9.0\n    */\n    this.bodyType = false;\n\n    /**\n    * Ray casting stats.\n    *\n    * @name Raycaster.Ray#_stats\n    * @type {object}\n    * @private\n    * @since 0.10.0\n    * \n    * @property {string} method Used casting method (cast, castCircle, castCone).\n    * @property {number} rays Casted rays.\n    * @property {number} testedMappedObjects Tested mapped objects.\n    * @property {number} hitMappedObjects Hit mapped objects.\n    * @property {number} segments Tested segments.\n    * @property {number} time Casting time.\n    */\n    this._stats = {\n        method: 'cast',\n        rays: 0,\n        testedMappedObjects: 0,\n        hitMappedObjects: 0,\n        segments: 0,\n        time: 0\n    };\n\n    /**\n    * Ray's graphics object used for debug\n    *\n    * @name Raycaster.Ray#graphics\n    * @type {Phaser.GameObjects.Graphics}\n    * @private\n    * @since 0.10.0\n    */\n     this.graphics;\n\n    this.config(options);\n};\n\nRay.prototype = {\n    config: require('./config.js').config,\n    getStats: require('./stats.js').getStats,\n    setRay: require('./ray.js').setRay,    \n    setOrigin: require('./origin.js').setOrigin,\n    setRayRange: require('./range.js').setRayRange,\n    setAngle: require('./angle.js').setAngle,\n    setAngleDeg: require('./angle.js').setAngleDeg,\n    setCone: require('./cone.js').setCone,\n    setConeDeg: require('./cone.js').setConeDeg,\n    setDetectionRange: require('./range.js').setDetectionRange,\n    boundsInRange: require('./range.js').boundsInRange,\n    cast: require('./cast.js').cast,\n    castCircle: require('./castCircle.js').castCircle,\n    castCone: require('./castCone.js').castCone,\n    slice: require('./slice.js').slice,\n    setCollisionRange: require('./range.js').setCollisionRange,\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\n    overlap: require('./overlap.js').overlap,\n    processOverlap: require('./overlap.js').processOverlap,\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\n    drawDebug: require('./debug.js').drawDebug,\n    destroy: require('./destroy.js').destroy,\n};\n","/**\n * Set ray's position, direction (angle) and range.\n *\n * @method Raycaster.Ray#setRay\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.6.0\n *\n * @param {number} x - X coordinate.\n * @param {number} y - Y coordinate.\n * @param {number} [angle] - Ray's angle in radians.\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\n *\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\n */\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\n    this.origin.setTo(x, y);\n    this.angle = Phaser.Math.Angle.Normalize(angle);\n    this.rayRange = rayRange;\n\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\n    return this;\n}\n","/**\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\n *\n * @method Raycaster.Ray#slice\n * @memberof Raycaster.Ray\n * @instance\n * @since 0.8.0\n *\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\n *\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\n */\nexport function slice(intersections = this.intersections, closed = true) {\n    //if intersections is Phaser.Geom.Polygon object\n    if(!Array.isArray(intersections)) {\n        if(intersections.type === 4)\n            intersections = intersections.points;\n        else\n            return [];\n    }\n\n    if(intersections.length === 0)\n        return [];\n\n    let slices = [];\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\n    }\n\n    if(closed)\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\n\n    return slices;\n}\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2023 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.7';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    /**\r\n    * Array of dynamic mapped game objects.\r\n    *\r\n    * @name Raycaster#dynamicMappedObjects\r\n    * @type {object[]}\r\n    * @since 0.10.6\r\n    */\r\n     this.dynamicMappedObjects = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update, this);\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update, this);\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            //remove object from mapped objects list\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index === -1) {\r\n                continue;\r\n            }\r\n            \r\n            this.mappedObjects.splice(index, 1);\r\n            \r\n            //remove object from dynamic mapped objects list\r\n            index = this.dynamicMappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.dynamicMappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap.destroy();\r\n            }\r\n            else {\r\n                object.data.get('raycasterMap').destroy();\r\n            }\r\n            \r\n            //update stats            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n        this._stats.mappedObjects.dynamic = this.dynamicMappedObjects.length;\r\n        this._stats.mappedObjects.static = this._stats.mappedObjects.total - this.dynamicMappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        if(this.dynamicMappedObjects.length > 0) {\r\n            for(let mapppedObject of this.dynamicMappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.active) {\r\n                    map.updateMap();\r\n                }\r\n            }\r\n        }\r\n\r\n        //debug\r\n        if(this.debugOptions.enabled)\r\n            this.drawDebug();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n            \r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else if(object.data)\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n        \r\n        if(this.graphics)\r\n            this.graphics.destroy();\r\n        \r\n        if(this.scene) {\r\n            this.scene.events.removeListener('update', null, this);\r\n        }\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.js\");\n",""],"names":["PhaserRaycaster","_Phaser$Plugins$Scene","_inherits","_super","_createSuper","scene","pluginManager","_this","_classCallCheck","call","_Raycaster","require","Raycaster","_createClass","key","value","createRaycaster","options","arguments","length","undefined","Phaser","Plugins","ScenePlugin","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","ray","_points","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","_iterator","_createForOfIteratorHelper","_step","s","n","done","point","err","e","f","_iterator2","_step2","i","isChild","tempRay","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","_iterator3","_step3","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","childPoints","_iterator4","_step4","_iterator5","_step5","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","_iterator6","_step6","childMapCircle","Map","raycaster","_dynamic","prototype","dynamicMappedObjects","_stats","mappedObjects","static","total","index","indexOf","splice","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","_loop","find","_loop2","segmentIndex","findIndex","x1","y1","x2","y2","_ret","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","prevPoint","slice","nextPoint","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","_i","_verticals","column","filter","_iterator7","_step7","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","boundingBoxIntersections","canTestMap","_boundingBox","setTo","_boundingBoxIntersect","boundingBoxIntersection","Equals","isTangent","circleIntersections","GetLineToCircle","_iterator8","_step8","result","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","_rayTargets","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","version","mapPoint","mapSegment","mapBoundingBox","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","_typeof","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","enableMaps","disableMaps","mapppedObject","strokeRectShape","removeListener"],"sourceRoot":""}